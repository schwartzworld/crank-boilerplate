import { CrankEventTarget } from "./events";
import { MaybePromise, MaybePromiseLike } from "./pledge";
export { EventMap } from "./events";
export declare type Tag = Component | string | symbol;
export declare type Key = unknown;
export declare type Child = Element | string | number | boolean | null | undefined;
interface ChildIterable extends Iterable<Child | ChildIterable> {
}
export declare type Children = Child | ChildIterable;
export interface Props {
    "crank-key"?: Key;
    children?: Children;
    [name: string]: any;
}
export interface IntrinsicProps<T> {
    children: Array<T | string>;
    [name: string]: any;
}
declare const ElementSigil: unique symbol;
export interface Element<TTag extends Tag = Tag> {
    [ElementSigil]: true;
    readonly tag: TTag;
    props: Props;
    key?: unknown;
}
export declare type FunctionComponent = (this: Context, props: Props) => MaybePromiseLike<Child>;
export declare type ChildIterator<T = any> = Iterator<Child, Child, T> | AsyncIterator<Child, Child, T>;
export declare type ChildGenerator<T = any> = Generator<Child, Child, T> | AsyncGenerator<Child, Child, T>;
export declare type GeneratorComponent = (this: Context, props: Props) => ChildIterator;
export declare type Component = (this: Context, props: Props) => ChildIterator | MaybePromiseLike<Child>;
export declare type Intrinsic<T> = (this: HostContext, props: IntrinsicProps<T>) => Iterator<T> | T;
export declare const Fragment: any;
export declare type Fragment = typeof Fragment;
export declare const Copy: any;
export declare type Copy = typeof Copy;
export declare const Portal: any;
export declare type Portal = typeof Portal;
export declare const Raw: any;
export declare type Raw = typeof Raw;
declare global {
    module JSX {
        interface IntrinsicElements {
            [tag: string]: any;
        }
        interface ElementChildrenAttribute {
            children: {};
        }
    }
}
export declare function isElement(value: any): value is Element;
export declare function createElement<TTag extends Tag>(tag: TTag, props?: Props | null, ...children: Array<Children>): Element<TTag>;
declare type Node<T> = LeafNode<T> | ParentNode<T>;
interface NodeBase<T> {
    readonly internal: boolean;
    readonly tag: Tag | undefined;
    readonly key: Key;
    value: Array<T | string> | T | string | undefined;
    nextSibling: Node<T> | undefined;
    previousSibling: Node<T> | undefined;
    clock: number;
    replacedBy: Node<T> | undefined;
}
declare class LeafNode<T> implements NodeBase<T> {
    readonly internal = false;
    readonly tag: undefined;
    readonly key: undefined;
    nextSibling: Node<T> | undefined;
    previousSibling: Node<T> | undefined;
    clock: number;
    replacedBy: Node<T> | undefined;
    value: string | undefined;
}
declare abstract class ParentNode<T> implements NodeBase<T> {
    readonly internal = true;
    abstract readonly tag: Tag;
    readonly key: Key;
    nextSibling: Node<T> | undefined;
    previousSibling: Node<T> | undefined;
    clock: number;
    replacedBy: Node<T> | undefined;
    private firstChild;
    private lastChild;
    private keyedChildren;
    abstract readonly renderer: Renderer<T>;
    abstract parent: ParentNode<T> | undefined;
    private onNextChildren;
    protected props: Props | undefined;
    value: Array<T | string> | T | string | undefined;
    ctx: Context | undefined;
    protected updating: boolean;
    protected iterating: boolean;
    protected finished: boolean;
    protected unmounted: boolean;
    private appendChild;
    private insertBefore;
    private removeChild;
    private replaceChild;
    protected getChildValues(): Array<T | string>;
    protected updateChildren(children: Children): MaybePromise<undefined>;
    protected unmountChildren(): void;
    update(props: Props): MaybePromise<undefined>;
    refresh(): MaybePromise<undefined>;
    abstract commit(): MaybePromise<undefined>;
    abstract unmount(): MaybePromise<undefined>;
    catch(reason: any): MaybePromise<undefined>;
}
declare class HostNode<T> extends ParentNode<T> {
    readonly tag: string | symbol;
    readonly key: Key;
    readonly parent: ParentNode<T> | undefined;
    readonly renderer: Renderer<T>;
    value: T | undefined;
    private childValues;
    private readonly intrinsic;
    private iterator;
    private readonly hostCtx;
    constructor(parent: ParentNode<T> | undefined, renderer: Renderer<T>, tag: string | symbol, key?: unknown);
    commit(): MaybePromise<undefined>;
    unmount(): MaybePromise<undefined>;
    [Symbol.iterator](): Generator<{
        children: (string | T)[];
        "crank-key"?: unknown;
    }, void, unknown>;
}
declare class ComponentNode<T> extends ParentNode<T> {
    readonly tag: Component;
    readonly key: Key;
    readonly parent: ParentNode<T>;
    readonly renderer: Renderer<T>;
    readonly ctx: Context;
    private available;
    private iterator;
    private componentType;
    private inflightPending;
    private enqueuedPending;
    private inflightResult;
    private enqueuedResult;
    private previousResult;
    private provisions;
    private publish;
    constructor(parent: ParentNode<T>, renderer: Renderer<T>, tag: Component, key: Key);
    private step;
    private advance;
    refresh(): MaybePromise<undefined>;
    [Symbol.iterator](): Generator<Props>;
    [Symbol.asyncIterator](): AsyncGenerator<Props>;
    private run;
    commit(): undefined;
    unmount(): MaybePromise<undefined>;
    catch(reason: any): MaybePromise<undefined>;
    get(name: unknown): any;
    set(name: unknown, value: any): void;
}
export declare class HostContext<T = any> {
    constructor(host: HostNode<T>);
    [Symbol.iterator](): Generator<IntrinsicProps<T>>;
}
export interface ProvisionMap {
}
export declare class Context extends CrankEventTarget {
    constructor(host: ComponentNode<any>, parent?: Context);
    get<T extends keyof ProvisionMap>(name: T): ProvisionMap[T];
    get(name: any): any;
    set<T extends keyof ProvisionMap>(name: T, value: ProvisionMap[T]): void;
    set(name: any, value: any): void;
    [Symbol.iterator](): Generator<Props>;
    [Symbol.asyncIterator](): AsyncGenerator<Props>;
    refresh(): MaybePromise<undefined>;
}
export declare const Default: unique symbol;
export declare type Default = typeof Default;
export declare const Text: unique symbol;
export declare type Text = typeof Text;
export interface Environment<T> {
    [Default](tag: string): Intrinsic<T>;
    [Text]?(text: string): string;
    [tag: string]: Intrinsic<T>;
}
export declare class Renderer<T> {
    private cache;
    private env;
    constructor(env?: Environment<T>);
    extend(env: Partial<Environment<T>>): void;
    render(child: Child, root?: object): MaybePromise<T>;
    intrinsic(tag: string | symbol): Intrinsic<T>;
    text(text: string): string;
}
