'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('./_tslib-7cf18fc1.js');
var repeater = require('@repeaterjs/repeater');
var eventTargetShim = require('event-target-shim');
var pledge = require('./pledge-49715615.js');

function normalizeOptions(options) {
    var capture = false;
    var passive;
    var once;
    if (typeof options === "boolean") {
        capture = options;
    }
    else if (options != null) {
        capture = !!options.capture;
        passive = options.passive;
        once = options.once;
    }
    return { capture: capture, passive: passive, once: once };
}
// TODO: strongly typed events somehow
var CrankEventTarget = /** @class */ (function (_super) {
    _tslib.__extends(CrankEventTarget, _super);
    function CrankEventTarget(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        // TODO: maybe use a helper class?
        // we need a map from:
        // type -> capture -> listener record
        // for efficient querying
        _this.listeners = [];
        _this._delegates = new Set();
        return _this;
    }
    Object.defineProperty(CrankEventTarget.prototype, "delegates", {
        get: function () {
            return this._delegates;
        },
        set: function (delegates) {
            var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
            var _this = this;
            var removed = new Set(Array.from(this._delegates).filter(function (d) { return !delegates.has(d); }));
            var added = new Set(Array.from(delegates).filter(function (d) { return !_this._delegates.has(d); }));
            try {
                for (var removed_1 = _tslib.__values(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {
                    var delegate = removed_1_1.value;
                    try {
                        for (var _e = (e_2 = void 0, _tslib.__values(this.listeners)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var listener = _f.value;
                            delegate.removeEventListener(listener.type, listener.callback, listener.options);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (removed_1_1 && !removed_1_1.done && (_a = removed_1.return)) _a.call(removed_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            try {
                for (var added_1 = _tslib.__values(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {
                    var delegate = added_1_1.value;
                    try {
                        for (var _g = (e_4 = void 0, _tslib.__values(this.listeners)), _h = _g.next(); !_h.done; _h = _g.next()) {
                            var listener = _h.value;
                            delegate.addEventListener(listener.type, listener.callback, listener.options);
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (_h && !_h.done && (_d = _g.return)) _d.call(_g);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (added_1_1 && !added_1_1.done && (_c = added_1.return)) _c.call(added_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            this._delegates = delegates;
        },
        enumerable: true,
        configurable: true
    });
    CrankEventTarget.prototype.addEventListener = function (type, callback, options) {
        var e_5, _a;
        if (callback == null) {
            return;
        }
        else if (typeof callback === "object") {
            throw new Error("Listener objects are not supported");
        }
        options = normalizeOptions(options);
        var record = { type: type, callback: callback, options: options };
        if (options.once) {
            var self_1 = this;
            record.callback = function (ev) {
                var result = callback.call(this, ev);
                self_1.removeEventListener(record.type, record.callback, record.options);
                return result;
            };
        }
        if (record.type.slice(0, 6) !== "crank.") {
            var idx = this.listeners.findIndex(function (record1) {
                return (record.type === record1.type &&
                    record.callback === record1.callback &&
                    record.options.capture === record1.options.capture);
            });
            if (idx <= -1) {
                this.listeners.push(record);
            }
        }
        try {
            for (var _b = _tslib.__values(this.delegates), _c = _b.next(); !_c.done; _c = _b.next()) {
                var delegate = _c.value;
                delegate.addEventListener(type, callback, options);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return _super.prototype.addEventListener.call(this, type, callback, options);
    };
    CrankEventTarget.prototype.removeEventListener = function (type, callback, options) {
        var e_6, _a;
        if (callback == null) {
            return;
        }
        var capture = typeof options === "boolean" ? options : !!(options && options.capture);
        var idx = this.listeners.findIndex(function (record) {
            return (record.type === type &&
                record.callback === callback &&
                record.options.capture === capture);
        });
        var record = this.listeners[idx];
        if (record !== undefined) {
            this.listeners.splice(idx, 1);
        }
        try {
            for (var _b = _tslib.__values(this.delegates), _c = _b.next(); !_c.done; _c = _b.next()) {
                var delegate = _c.value;
                delegate.removeEventListener(type, callback, options);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
        return _super.prototype.removeEventListener.call(this, type, callback, options);
    };
    CrankEventTarget.prototype.clearEventListeners = function () {
        var e_7, _a;
        try {
            for (var _b = _tslib.__values(this.listeners.slice()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var listener = _c.value;
                this.removeEventListener(listener.type, listener.callback, listener.options);
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
    };
    // TODO: ev is any because event-target-shim has a weird dispatchEvent type
    CrankEventTarget.prototype.dispatchEvent = function (ev) {
        var continued = _super.prototype.dispatchEvent.call(this, ev);
        if (continued && ev.bubbles && this.parent !== undefined) {
            // TODO: implement event capturing
            continued = this.parent.dispatchEvent(ev);
        }
        return continued;
    };
    return CrankEventTarget;
}(eventTargetShim.EventTarget));
function isEventTarget(value) {
    return (value != null &&
        typeof value.addEventListener === "function" &&
        typeof value.removeEventListener === "function" &&
        typeof value.dispatchEvent === "function");
}

var _a;
function isIterable(value) {
    return value != null && typeof value[Symbol.iterator] === "function";
}
function isNonStringIterable(value) {
    return typeof value !== "string" && isIterable(value);
}
function isIteratorOrAsyncIterator(value) {
    return value != null && typeof value.next === "function";
}
// TODO: rename
var Default = Symbol.for("crank.Default");
// TODO: rename
var Text = Symbol.for("crank.Text");
// TODO: We use any for symbol tags because typescript support for symbols is weak af.
var Portal = Symbol.for("crank.Portal");
var Fragment = Symbol.for("crank.Fragment");
var Copy = Symbol("crank.Copy");
var ElementSigil = Symbol.for("crank.ElementSigil");
function isElement(value) {
    return value != null && value[ElementSigil];
}
function isIntrinsicElement(value) {
    return isElement(value) && typeof value.tag !== "function";
}
function isComponentElement(value) {
    return isElement(value) && typeof value.tag === "function";
}
function isKeyedElement(value) {
    return isElement(value) && value.key != null;
}
function createElement(tag, props) {
    var _a;
    props = Object.assign({}, props);
    var key = props["crank-key"];
    if (key != null) {
        delete props["crank-key"];
    }
    if (arguments.length > 3) {
        props.children = Array.from(arguments).slice(2);
    }
    else if (arguments.length > 2) {
        props.children = arguments[2];
    }
    return _a = {}, _a[ElementSigil] = true, _a.tag = tag, _a.props = props, _a.key = key, _a;
}
function toGuest(child) {
    if (child == null || typeof child === "boolean") {
        return undefined;
    }
    else if (typeof child === "string" || isElement(child)) {
        return child;
    }
    else {
        return child.toString();
    }
}
// TODO: explain what this function does
function chase(fn) {
    var next = function () { };
    return function chaseWrapper() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var result = fn.apply(this, args);
        next(result);
        if (pledge.isPromiseLike(result)) {
            var nextP = new Promise(function (resolve) { return (next = resolve); });
            return Promise.race([result, nextP]);
        }
        return result;
    };
}
var Link = /** @class */ (function () {
    function Link() {
    }
    Link.prototype.insertBefore = function (newLink, refLink) {
        newLink.nextSibling = refLink;
        if (refLink.previousSibling === undefined) {
            newLink.previousSibling = undefined;
            this.firstChild = newLink;
        }
        else {
            newLink.previousSibling = refLink.previousSibling;
            refLink.previousSibling.nextSibling = newLink;
        }
        refLink.previousSibling = newLink;
    };
    Link.prototype.insertAfter = function (newLink, refLink) {
        newLink.previousSibling = refLink;
        if (refLink.nextSibling === undefined) {
            newLink.nextSibling = undefined;
            this.lastChild = newLink;
        }
        else {
            newLink.nextSibling = refLink.nextSibling;
            refLink.nextSibling.previousSibling = newLink;
        }
        refLink.nextSibling = newLink;
    };
    Link.prototype.appendChild = function (link) {
        if (this.lastChild === undefined) {
            this.firstChild = link;
            this.lastChild = link;
            link.previousSibling = undefined;
            link.nextSibling = undefined;
        }
        else {
            this.insertAfter(link, this.lastChild);
        }
    };
    Link.prototype.removeChild = function (link) {
        if (link.previousSibling === undefined) {
            this.firstChild = link.nextSibling;
        }
        else {
            link.previousSibling.nextSibling = link.nextSibling;
        }
        if (link.nextSibling === undefined) {
            this.lastChild = link.previousSibling;
        }
        else {
            link.nextSibling.previousSibling = link.previousSibling;
        }
    };
    Link.prototype.replaceChild = function (newLink, refLink) {
        this.insertBefore(newLink, refLink);
        this.removeChild(refLink);
    };
    return Link;
}());
var Host = /** @class */ (function (_super) {
    _tslib.__extends(Host, _super);
    function Host(parent, 
    // TODO: Figure out a way to not have to pass in a renderer
    renderer) {
        var _this = _super.call(this) || this;
        _this.publications = new Set();
        // TODO: reduce the number of boolean properties
        _this.updating = false;
        _this.done = false;
        _this.unmounted = false;
        _this.independent = false;
        _this.clock = 0;
        // TODO: clean up this monster
        _this.updateChildren = chase(function updateChildren(children) {
            var e_1, _a, e_2, _b;
            var _this = this;
            var host = this.firstChild;
            var promises = [];
            var hostsByKey;
            if (children != null) {
                if (!isNonStringIterable(children)) {
                    children = [children];
                }
                var _loop_1 = function (child) {
                    if (isNonStringIterable(child)) {
                        child = createElement(Fragment, null, child);
                    }
                    var guest = toGuest(child);
                    var tag = void 0;
                    var key = void 0;
                    var isNewHost = false;
                    if (isElement(guest)) {
                        tag = guest.tag;
                        key = guest.key;
                        if (hostsByKey !== undefined && hostsByKey.has(key)) {
                            // TODO: warn about a duplicate key
                            key = undefined;
                        }
                    }
                    if (key != null) {
                        var newHost = this_1.hostsByKey && this_1.hostsByKey.get(key);
                        if (newHost === undefined) {
                            newHost = new Host(this_1, this_1.renderer);
                            isNewHost = true;
                        }
                        else {
                            this_1.hostsByKey.delete(key);
                            if (host !== newHost) {
                                this_1.removeChild(newHost);
                            }
                        }
                        if (host === undefined) {
                            this_1.appendChild(newHost);
                        }
                        else if (host !== newHost) {
                            if (isKeyedElement(host.guest)) {
                                this_1.insertAfter(newHost, host);
                            }
                            else {
                                this_1.insertBefore(newHost, host);
                            }
                        }
                        host = newHost;
                    }
                    else if (host === undefined) {
                        host = new Host(this_1, this_1.renderer);
                        this_1.appendChild(host);
                        isNewHost = true;
                    }
                    else if (host.key != null) {
                        var newHost = new Host(this_1, this_1.renderer);
                        this_1.insertAfter(newHost, host);
                        host = newHost;
                        isNewHost = true;
                    }
                    if (tag !== Copy) {
                        if (isNewHost || (!host.unmounted && host.tag === tag)) {
                            var updateP = host.update(guest);
                            if (updateP !== undefined) {
                                promises.push(updateP);
                            }
                        }
                        else {
                            // replace the host with another one
                            var clock = host.clock++;
                            var newHost_1 = new Host(this_1, this_1.renderer);
                            newHost_1.clock = clock;
                            var updateP = newHost_1.update(guest);
                            if (updateP === undefined) {
                                host.unmount();
                                this_1.replaceChild(newHost_1, host);
                                host.replacedBy = newHost_1;
                            }
                            else {
                                // TODO: unmount only when the host is ready to be replaced
                                host.unmount();
                                promises.push(updateP);
                                var host1_1 = host;
                                updateP.then(function () {
                                    if (host1_1.replacedBy === undefined) {
                                        _this.replaceChild(newHost_1, host1_1);
                                        host1_1.replacedBy = newHost_1;
                                    }
                                    else if (host1_1.replacedBy.replacedBy === undefined &&
                                        host1_1.replacedBy.clock < newHost_1.clock) {
                                        _this.replaceChild(newHost_1, host1_1.replacedBy);
                                        host1_1.replacedBy = newHost_1;
                                    }
                                });
                            }
                        }
                    }
                    if (key !== undefined) {
                        if (hostsByKey === undefined) {
                            hostsByKey = new Map();
                        }
                        hostsByKey.set(key, host);
                    }
                    host = host.nextSibling;
                };
                var this_1 = this;
                try {
                    for (var children_1 = _tslib.__values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {
                        var child = children_1_1.value;
                        _loop_1(child);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            // unmounting excess hosts
            while (host !== undefined) {
                if (this.hostsByKey !== undefined && host.key !== undefined) {
                    this.hostsByKey.delete(host.key);
                }
                host.unmount();
                var nextSibling = host.nextSibling;
                this.removeChild(host);
                host = nextSibling;
            }
            // unmounting keyed hosts
            if (this.hostsByKey) {
                try {
                    for (var _c = _tslib.__values(this.hostsByKey.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var host_1 = _d.value;
                        // TODO: implement async unmount for keyed hosts
                        host_1.unmount();
                        this.removeChild(host_1);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            this.hostsByKey = hostsByKey;
            // TODO: can we move this somewhere else
            if (promises.length) {
                return Promise.all(promises).then(function () { return void _this.commit(); }); // void :(
            }
            else {
                this.commit();
            }
        });
        _this.parent = parent;
        _this.renderer = renderer;
        return _this;
    }
    Object.defineProperty(Host.prototype, "tag", {
        // TODO: flatten these instead of storing guest
        get: function () {
            return isElement(this.guest) ? this.guest.tag : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Host.prototype, "key", {
        get: function () {
            return isElement(this.guest) ? this.guest.key : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Host.prototype, "props", {
        get: function () {
            return isElement(this.guest) ? this.guest.props : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Host.prototype, "childNodes", {
        get: function () {
            if (this.cachedChildNodes !== undefined) {
                return this.cachedChildNodes;
            }
            var buffer;
            var childNodes = [];
            for (var host = this.firstChild; host !== undefined; host = host.nextSibling) {
                if (typeof host.node === "string") {
                    buffer = (buffer || "") + host.node;
                }
                else if (host.tag !== Portal) {
                    if (buffer !== undefined) {
                        childNodes.push(buffer);
                        buffer = undefined;
                    }
                    if (host.node === undefined) {
                        childNodes.push.apply(childNodes, _tslib.__spread(host.childNodes));
                    }
                    else {
                        childNodes.push(host.node);
                    }
                }
            }
            if (buffer !== undefined) {
                childNodes.push(buffer);
            }
            if (this.ctx !== undefined && typeof this.tag === "function") {
                // TODO: filter predicate type narrowing is not working
                this.ctx.delegates = new Set(childNodes.filter(isEventTarget));
            }
            this.cachedChildNodes = childNodes;
            return childNodes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Host.prototype, "childNodeOrNodes", {
        get: function () {
            if (this.childNodes.length > 1) {
                return this.childNodes;
            }
            return this.childNodes[0];
        },
        enumerable: true,
        configurable: true
    });
    Host.prototype.update = function (guest) {
        this.updating = true;
        if (this.tag === undefined) {
            if (isElement(guest)) {
                this.ctx = new Context(this, this.parent && this.parent.ctx);
                if (typeof guest.tag !== "function") {
                    this.intrinsic = this.renderer.intrinsicFor(guest.tag);
                }
            }
        }
        this.guest = guest;
        return this.refresh();
    };
    Host.prototype.step = function (next) {
        var _this = this;
        if (this.ctx === undefined) {
            throw new Error("Missing context");
        }
        else if (!isComponentElement(this.guest)) {
            throw new Error("Non-component element as guest");
        }
        if (this.iterator === undefined) {
            this.ctx.clearEventListeners();
            // TODO: can we have pledges take an executor to reduce error duplication
            var value = void 0;
            try {
                value = this.guest.tag.call(this.ctx, this.guest.props);
                if (pledge.isPromiseLike(value)) {
                    value = Promise.resolve(value).catch(function (err) {
                        if (_this.parent === undefined) {
                            throw err;
                        }
                        _this.parent.catch(err);
                        return undefined;
                    });
                    return value;
                }
            }
            catch (err) {
                if (this.parent === undefined) {
                    throw err;
                }
                this.parent.catch(err);
                return;
            }
            if (isIteratorOrAsyncIterator(value)) {
                this.iterator = value;
            }
            else {
                return value;
            }
        }
        else if (this.done) {
            return;
        }
        var iteration;
        // TODO: figure out if we can have pledges take a callback to reduce duplication when catching events
        try {
            iteration = this.iterator.next(next);
            if (pledge.isPromiseLike(iteration)) {
                iteration = iteration.catch(function (err) {
                    if (_this.parent === undefined) {
                        throw err;
                    }
                    _this.parent.catch(err);
                    return undefined;
                });
            }
        }
        catch (err) {
            if (this.parent === undefined) {
                throw err;
            }
            this.parent.catch(err);
            return;
        }
        if (pledge.isPromiseLike(iteration)) {
            this.independent = true;
            return iteration.then(function (iteration) {
                var updateP = new pledge.Pledge(iteration.value).then(function (child) {
                    return _this.updateChildren(child);
                });
                var next = new pledge.Pledge(updateP).then(function () { return _this.childNodeOrNodes; });
                if (iteration.done) {
                    _this.done = true;
                }
                else if (!_this.done) {
                    _this.pending = new Promise(function (resolve) { return setFrame(resolve); }).then(function () {
                        return _this.step(next);
                    });
                }
                return updateP;
            });
        }
        if (iteration.done) {
            this.done = true;
        }
        return new pledge.Pledge(iteration.value).then(function (child) { return _this.updateChildren(child); });
    };
    Host.prototype.run = function () {
        var _this = this;
        if (this.pending === undefined) {
            var next = this.iterator === undefined ? undefined : this.childNodeOrNodes;
            var step = this.step(next);
            if (this.iterator === undefined) {
                if (pledge.isPromiseLike(step)) {
                    this.pending = Promise.resolve(step).finally(function () {
                        _this.pending = _this.enqueued;
                        _this.enqueued = undefined;
                    });
                    return Promise.resolve(step).then(function (child) {
                        return _this.updateChildren(child);
                    });
                }
                else {
                    return this.updateChildren(step);
                }
            }
            else if (pledge.isPromiseLike(step)) {
                this.pending = Promise.resolve(step);
                if (!this.independent) {
                    this.pending.finally(function () {
                        _this.pending = _this.enqueued;
                        _this.enqueued = undefined;
                    });
                }
            }
            return this.pending;
        }
        else if (this.independent) {
            return this.pending;
        }
        else if (this.enqueued === undefined) {
            this.enqueued = this.pending.then(function () { return _this.step(_this.childNodeOrNodes); }, function () { return _this.step(_this.childNodeOrNodes); });
            if (this.iterator === undefined) {
                this.enqueued = this.enqueued.then(function (child) {
                    return _this.updateChildren(child);
                });
            }
            this.enqueued.finally(function () {
                _this.pending = _this.enqueued;
                _this.enqueued = undefined;
            });
        }
        return this.enqueued;
    };
    Host.prototype.refresh = function () {
        var e_3, _a;
        if (this.unmounted) {
            return;
        }
        else if (this.tag !== undefined) {
            try {
                for (var _b = _tslib.__values(this.publications), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var pub = _c.value;
                    pub.push(this.props);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            if (typeof this.tag === "function") {
                return this.run();
            }
            else {
                return this.updateChildren(this.props && this.props.children);
            }
        }
        else if (typeof this.guest === "string") {
            this.node = this.renderer.text(this.guest);
        }
        else {
            this.node = undefined;
        }
    };
    Host.prototype.commit = function () {
        this.cachedChildNodes = undefined;
        if (isElement(this.guest)) {
            if (typeof this.guest.tag === "function") {
                if (!this.updating && this.parent !== undefined) {
                    // TODO: batch this per microtask
                    this.parent.commit();
                }
            }
            else {
                if (this.committer === undefined &&
                    this.intrinsic !== undefined &&
                    this.ctx !== undefined) {
                    var value = this.intrinsic.call(this.ctx, this.guest.props);
                    if (isIteratorOrAsyncIterator(value)) {
                        this.committer = value;
                    }
                    else {
                        this.node = value;
                    }
                }
                if (this.committer !== undefined) {
                    var iteration = this.committer.next();
                    this.node = iteration.value;
                    if (iteration.done) {
                        this.committer = undefined;
                        this.intrinsic = undefined;
                    }
                }
                if (this.node == null && this.parent !== undefined) {
                    this.parent.commit();
                }
            }
        }
        this.updating = false;
    };
    Host.prototype.catch = function (reason) {
        var _this = this;
        if (this.iterator === undefined ||
            this.iterator.throw === undefined ||
            this.done) {
            if (this.parent === undefined) {
                throw reason;
            }
            this.parent.catch(reason);
        }
        else {
            try {
                // TODO: catch async errors too
                var iteration = this.iterator.throw(reason);
                new pledge.Pledge(iteration).then(function (iteration) {
                    if (iteration.done) {
                        _this.done = true;
                    }
                    _this.updateChildren(iteration.value);
                });
            }
            catch (err) {
                if (this.parent === undefined) {
                    throw err;
                }
                this.parent.catch(err);
            }
        }
    };
    Host.prototype.unmount = function () {
        var e_4, _a;
        try {
            for (var _b = _tslib.__values(this.publications), _c = _b.next(); !_c.done; _c = _b.next()) {
                var pub = _c.value;
                pub.stop();
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        // TODO: await the return if the host is keyed and commit the parent
        if (!this.done) {
            if (this.iterator !== undefined && this.iterator.return) {
                this.iterator.return();
            }
            if (this.committer && this.committer.return) {
                this.committer.return();
            }
        }
        this.unmounted = true;
        this.committer = undefined;
        this.iterator = undefined;
        this.updating = false;
        this.unmountChildren();
    };
    Host.prototype.unmountChildren = function () {
        var host = this.firstChild;
        while (host !== undefined) {
            // TODO: catch errors
            host.unmount();
            host = host.nextSibling;
        }
    };
    return Host;
}(Link));
var hosts = new WeakMap();
var Context = /** @class */ (function (_super) {
    _tslib.__extends(Context, _super);
    function Context(host, parent) {
        var _this = _super.call(this, parent) || this;
        hosts.set(_this, host);
        return _this;
    }
    Object.defineProperty(Context.prototype, "node", {
        get: function () {
            return hosts.get(this).node;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "childNodes", {
        get: function () {
            return hosts.get(this).childNodes;
        },
        enumerable: true,
        configurable: true
    });
    // TODO: throw an error if props are pulled multiple times without a yield
    Context.prototype[Symbol.iterator] = function () {
        var host;
        return _tslib.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    host = hosts.get(this);
                    _a.label = 1;
                case 1:
                    return [4 /*yield*/, host.props];
                case 2:
                    _a.sent();
                    return [3 /*break*/, 1];
                case 3: return [2 /*return*/];
            }
        });
    };
    // TODO: throw an error if props are pulled multiple times without a yield
    Context.prototype[Symbol.asyncIterator] = function () {
        var _this = this;
        var host = hosts.get(this);
        return new repeater.Repeater(function (push, stop) { return _tslib.__awaiter(_this, void 0, void 0, function () {
            var pub;
            return _tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        push(host.props);
                        pub = { push: push, stop: stop };
                        host.publications.add(pub);
                        return [4 /*yield*/, stop];
                    case 1:
                        _a.sent();
                        host.publications.delete(pub);
                        return [2 /*return*/];
                }
            });
        }); }, new repeater.SlidingBuffer(1));
    };
    // TODO: throw or warn if called on an unmounted component?
    Context.prototype.refresh = function () {
        var host = hosts.get(this);
        return host.refresh();
    };
    return Context;
}(CrankEventTarget));
var defaultEnv = (_a = {},
    _a[Default] = function (tag) {
        throw new Error("Environment did not provide an intrinsic for " + tag);
    },
    _a[Portal] = function () {
        throw new Error("Environment did not provide an intrinsic for Portal");
    },
    _a[Fragment] = function () {
        return undefined; // void :(
    },
    _a);
function setFrame(callback) {
    if (requestAnimationFrame !== undefined) {
        return requestAnimationFrame(callback);
    }
    else if (setImmediate !== undefined) {
        return setImmediate(function () { return callback(Date.now()); });
    }
    else {
        return setTimeout(function () { return callback(Date.now()); });
    }
}
function clearFrame(id) {
    if (requestAnimationFrame !== undefined) {
        cancelAnimationFrame(id);
    }
    else if (setImmediate !== undefined) {
        clearImmediate(id);
    }
    else {
        clearTimeout(id);
    }
}
var Renderer = /** @class */ (function () {
    function Renderer(env) {
        this.cache = new WeakMap();
        this.env = _tslib.__assign({}, defaultEnv);
        if (env) {
            this.extend(env);
        }
    }
    Renderer.prototype.getOrCreateHost = function (root) {
        var host;
        if (root !== undefined) {
            host = this.cache.get(root);
        }
        if (host === undefined) {
            host = new Host(undefined, this);
            if (root !== undefined) {
                this.cache.set(root, host);
            }
        }
        return host;
    };
    Renderer.prototype.extend = function (env) {
        var e_5, _a;
        if (env[Default] != null) {
            this.env[Default] = env[Default];
        }
        if (env[Portal] != null) {
            this.env[Portal] = env[Portal];
        }
        try {
            for (var _b = _tslib.__values(Object.entries(env)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = _tslib.__read(_c.value, 2), tag = _d[0], value = _d[1];
                if (value != null) {
                    this.env[tag] = value;
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
    };
    Renderer.prototype.intrinsicFor = function (tag) {
        if (this.env[tag]) {
            return this.env[tag];
        }
        else if (typeof tag === "string") {
            return this.env[Default](tag);
        }
        else {
            throw new Error("Unknown tag " + tag.toString());
        }
    };
    Renderer.prototype.text = function (text) {
        if (this.env[Text] !== undefined) {
            // TODO: remove non-null assertion when typescript gets its shit together with symbols
            return this.env[Text](text);
        }
        return text;
    };
    Renderer.prototype.render = function (child, root) {
        if (!isElement(child) || child.tag !== Portal) {
            child = createElement(Portal, { root: root }, child);
        }
        var host = this.getOrCreateHost(root);
        var p;
        if (child == null) {
            p = host.unmount();
        }
        else {
            p = host.update(toGuest(child));
        }
        return new pledge.Pledge(p).then(function () { return host.ctx; });
    };
    return Renderer;
}());

exports.Context = Context;
exports.Copy = Copy;
exports.Default = Default;
exports.Fragment = Fragment;
exports.Portal = Portal;
exports.Renderer = Renderer;
exports.Text = Text;
exports.clearFrame = clearFrame;
exports.createElement = createElement;
exports.isComponentElement = isComponentElement;
exports.isElement = isElement;
exports.isIntrinsicElement = isIntrinsicElement;
exports.isKeyedElement = isKeyedElement;
exports.setFrame = setFrame;
//# sourceMappingURL=index.js.map
