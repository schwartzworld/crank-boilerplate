import { CrankEventTarget } from "./events";
import { MaybePromise, MaybePromiseLike } from "./pledge";
declare global {
    module JSX {
        interface IntrinsicElements {
            [tag: string]: any;
        }
        interface ElementChildrenAttribute {
            children: Children;
        }
    }
}
export declare const Default: unique symbol;
export declare type Default = typeof Default;
export declare const Text: unique symbol;
export declare type Text = typeof Text;
export declare const Portal: any;
export declare type Portal = typeof Portal;
export declare const Fragment: any;
export declare type Fragment = typeof Fragment;
export declare const Copy: any;
export declare type Copy = typeof Copy;
export declare type Tag = Component | symbol | string;
export declare type Child = Element | string | number | boolean | null | undefined;
interface NestedChildIterable extends Iterable<Child | NestedChildIterable> {
}
export declare type Children = Child | NestedChildIterable;
export interface Props {
    children?: Children;
    "crank-key"?: unknown;
    [name: string]: any;
}
declare const ElementSigil: unique symbol;
export interface Element<T extends Tag = Tag> {
    [ElementSigil]: true;
    tag: T;
    props: Props;
    key?: unknown;
}
export declare function isElement(value: any): value is Element;
export declare function isIntrinsicElement(value: any): value is Element<string | symbol>;
export declare function isComponentElement(value: any): value is Element<Component>;
export declare function isKeyedElement(value: any): value is Element & {
    key: {};
};
export declare function createElement<T extends Tag>(tag: T, props?: Props | null, ...children: Children[]): Element<T>;
export declare type Intrinsic<T> = (props: Props) => T | Iterator<T>;
declare type Guest = Element | string | undefined;
declare class Link {
    protected parent?: Link;
    protected firstChild?: Link;
    protected lastChild?: Link;
    protected nextSibling?: Link;
    protected previousSibling?: Link;
    protected insertBefore(newLink: Link, refLink: Link): void;
    protected insertAfter(newLink: Link, refLink: Link): void;
    protected appendChild(link: Link): void;
    protected removeChild(link: Link): void;
    protected replaceChild(newLink: Link, refLink: Link): void;
}
interface Publication {
    push(props: Props): unknown;
    stop(): unknown;
}
declare class Host<T> extends Link {
    protected firstChild?: Host<T>;
    protected lastChild?: Host<T>;
    protected nextSibling?: Host<T>;
    protected previousSibling?: Host<T>;
    protected parent?: Host<T>;
    ctx?: Context<T>;
    guest?: Guest;
    node?: T | string;
    publications: Set<Publication>;
    private updating;
    private done;
    private unmounted;
    private independent;
    private pending?;
    private enqueued?;
    private replacedBy?;
    private clock;
    private iterator?;
    private committer?;
    private intrinsic?;
    private hostsByKey?;
    private renderer;
    constructor(parent: Host<T> | undefined, renderer: Renderer<T>);
    get tag(): Tag | undefined;
    get key(): unknown;
    get props(): Props | undefined;
    private cachedChildNodes?;
    get childNodes(): (T | string)[];
    get childNodeOrNodes(): (T | string)[] | T | string | undefined;
    update(guest: Guest): MaybePromise<undefined>;
    private step;
    run(): MaybePromise<undefined>;
    refresh(): MaybePromise<undefined>;
    updateChildren: (this: Host<T>, ...args: any[]) => MaybePromise<undefined>;
    commit(): void;
    catch(reason: any): void;
    unmount(): void;
    unmountChildren(): void;
}
export declare class Context<T = any> extends CrankEventTarget {
    constructor(host: Host<T>, parent?: Context<T>);
    get node(): T | string | undefined;
    get childNodes(): (T | string)[];
    [Symbol.iterator](): Generator<Props>;
    [Symbol.asyncIterator](): AsyncGenerator<Props>;
    refresh(): MaybePromise<undefined>;
}
export declare type FunctionComponent = (this: Context, props: Props) => MaybePromiseLike<Child>;
export declare type ChildIterator = Iterator<MaybePromiseLike<Child>, any, any> | AsyncIterator<MaybePromiseLike<Child>, any, any>;
export declare type GeneratorComponent = (this: Context, props: Props) => ChildIterator;
export declare type Component = (this: Context, props: Props) => ChildIterator | MaybePromiseLike<Child>;
export interface Environment<T> {
    [Default](tag: string): Intrinsic<T>;
    [Text]?(text: string): string;
    [tag: string]: Intrinsic<T>;
}
export declare function setFrame(callback: (time: number) => unknown): any;
export declare function clearFrame(id: any): void;
export declare class Renderer<T> {
    private cache;
    private getOrCreateHost;
    private env;
    constructor(env?: Environment<T>);
    extend(env: Partial<Environment<T>>): void;
    intrinsicFor(tag: string | symbol): Intrinsic<T>;
    text(text: string): string;
    render(child: Child, root?: object): MaybePromise<Context<T>>;
}
export {};
