export declare type MaybePromise<T> = Promise<T> | T;
export declare type MaybePromiseLike<T> = PromiseLike<T> | T;
export declare function isPromiseLike(value: any): value is PromiseLike<any>;
export declare function upgrade<T>(value: MaybePromiseLike<T>): MaybePromise<T>;
/**
 * A pledge is like a promise, except it runs synchronously if possible.
 *
 * It is not meant to be exposed in APIs; rather, you should unwrap pledges to
 * a possible promise by calling Pledge.prototype.execute.
 */
export declare class Pledge<T> {
    private executor;
    constructor(executor: () => MaybePromiseLike<T>);
    then<TFulfilled = T, TRejected = never>(onfulfilled?: ((value: T) => MaybePromiseLike<TFulfilled>) | null, onrejected?: ((reason: any) => MaybePromiseLike<TRejected>) | null): Pledge<TFulfilled | TRejected>;
    catch<TRejected = never>(onrejected?: ((reason: any) => MaybePromiseLike<TRejected>) | null): Pledge<T | TRejected>;
    finally(onfinally?: (() => unknown) | null): Pledge<T>;
    execute(): MaybePromise<T>;
    static resolve<T>(value: MaybePromiseLike<T>): Pledge<T>;
}
