import { D as Default, _ as __generator, R as Raw, P as Portal, d as __extends, b as Renderer, e as __rest, f as __values, g as __assign } from './index-06d991e2.js';

var _a;
// TODO: create an allowlist/blocklist of props
function updateProps(el, props, newProps) {
    for (var name_1 in __assign(__assign({}, props), newProps)) {
        var value = props[name_1];
        var newValue = newProps[name_1];
        switch (true) {
            case name_1 === "children":
                break;
            case name_1 === "class":
            case name_1 === "className": {
                el["className"] = newValue;
                break;
            }
            case name_1 === "style" && "style" in el: {
                var style = el.style;
                if (newValue == null) {
                    el.removeAttribute("style");
                }
                else if (typeof newValue === "string") {
                    style.cssText = newValue;
                }
                else {
                    for (var styleName in Object.assign({}, value, newValue)) {
                        var styleValue = value && value[styleName];
                        var newStyleValue = newValue && newValue[styleName];
                        if (newStyleValue == null) {
                            style.removeProperty(styleName);
                        }
                        else if (styleValue !== newStyleValue) {
                            style.setProperty(styleName, newStyleValue);
                        }
                    }
                }
                break;
            }
            default: {
                if (name_1 in el) {
                    el[name_1] = newValue;
                    break;
                }
                else if (newValue === true) {
                    el.setAttribute(name_1, "");
                }
                else if (newValue === false || newValue == null) {
                    el.removeAttribute(name_1);
                }
                else {
                    el.setAttribute(name_1, newValue);
                }
                break;
            }
        }
    }
}
// TODO: improve this algorithm
// https://stackoverflow.com/questions/59418120/what-is-the-most-efficient-way-to-update-the-childnodes-of-a-dom-node-with-an-ar
function updateChildren(el, children) {
    var e_1, _a, e_2, _b;
    if (el.childNodes.length === 0) {
        var fragment = document.createDocumentFragment();
        try {
            for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {
                var child = children_1_1.value;
                if (typeof child === "string") {
                    child = document.createTextNode(child);
                }
                fragment.appendChild(child);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        el.appendChild(fragment);
        return;
    }
    var oldChild = el.firstChild;
    try {
        for (var children_2 = __values(children), children_2_1 = children_2.next(); !children_2_1.done; children_2_1 = children_2.next()) {
            var newChild = children_2_1.value;
            if (oldChild === null) {
                el.appendChild(typeof newChild === "string"
                    ? document.createTextNode(newChild)
                    : newChild);
            }
            else if (typeof newChild === "string") {
                if (oldChild.nodeType === Node.TEXT_NODE) {
                    if (oldChild.nodeValue !== newChild) {
                        oldChild.nodeValue = newChild;
                    }
                    oldChild = oldChild.nextSibling;
                }
                else {
                    el.insertBefore(document.createTextNode(newChild), oldChild);
                }
            }
            else if (oldChild !== newChild) {
                el.insertBefore(newChild, oldChild);
            }
            else {
                oldChild = oldChild.nextSibling;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (children_2_1 && !children_2_1.done && (_b = children_2.return)) _b.call(children_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    while (oldChild !== null) {
        var nextSibling = oldChild.nextSibling;
        el.removeChild(oldChild);
        oldChild = nextSibling;
    }
}
function createDocumentFragmentFromHTML(html) {
    if (typeof document.createRange === "function") {
        return document.createRange().createContextualFragment(html);
    }
    else {
        var fragment = document.createDocumentFragment();
        var childNodes = new DOMParser().parseFromString(html, "text/html").body
            .childNodes;
        for (var i = 0; i < childNodes.length; i++) {
            fragment.appendChild(childNodes[i]);
        }
        return fragment;
    }
}
// TODO: Element should be ParentNode maybe?
var env = (_a = {},
    _a[Default] = function (tag) {
        return function defaultDOM() {
            var node, props, nextProps, children, nextChildren, _a, _b, _c, e_3_1;
            var e_3, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        node = document.createElement(tag);
                        props = {};
                        children = [];
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 6, 7, 8]);
                        _a = __values(this), _b = _a.next();
                        _e.label = 2;
                    case 2:
                        if (!!_b.done) return [3 /*break*/, 5];
                        _c = _b.value;
                        (nextChildren = _c.children, nextProps = __rest(_c, ["children"]));
                        updateProps(node, props, nextProps);
                        props = nextProps;
                        if (!("innerHTML" in nextProps) &&
                            (children.length > 0 || nextChildren.length > 0)) {
                            updateChildren(node, nextChildren);
                            children = nextChildren;
                        }
                        return [4 /*yield*/, node];
                    case 3:
                        _e.sent();
                        _e.label = 4;
                    case 4:
                        _b = _a.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_3_1 = _e.sent();
                        e_3 = { error: e_3_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                        }
                        finally { if (e_3) throw e_3.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        };
    },
    _a[Raw] = function (_a) {
        var value = _a.value;
        if (typeof value === "string") {
            // TODO: figure out what the type of element should actually be
            return createDocumentFragmentFromHTML(value);
        }
        else {
            return value;
        }
    },
    _a[Portal] = function (_a) {
        var _b, _c, _d, newRoot, children, e_4_1;
        var e_4, _e;
        var root = _a.root;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    if (root == null) {
                        throw new TypeError("Portal element is missing root node");
                    }
                    _f.label = 1;
                case 1:
                    _f.trys.push([1, , 10, 11]);
                    _f.label = 2;
                case 2:
                    _f.trys.push([2, 7, 8, 9]);
                    _b = __values(this), _c = _b.next();
                    _f.label = 3;
                case 3:
                    if (!!_c.done) return [3 /*break*/, 6];
                    _d = _c.value, newRoot = _d.root, children = _d.children;
                    if (newRoot == null) {
                        throw new TypeError("Portal element is missing root node");
                    }
                    if (root !== newRoot) {
                        updateChildren(root, []);
                        root = newRoot;
                    }
                    updateChildren(root, children);
                    return [4 /*yield*/, root];
                case 4:
                    _f.sent();
                    _f.label = 5;
                case 5:
                    _c = _b.next();
                    return [3 /*break*/, 3];
                case 6: return [3 /*break*/, 9];
                case 7:
                    e_4_1 = _f.sent();
                    e_4 = { error: e_4_1 };
                    return [3 /*break*/, 9];
                case 8:
                    try {
                        if (_c && !_c.done && (_e = _b.return)) _e.call(_b);
                    }
                    finally { if (e_4) throw e_4.error; }
                    return [7 /*endfinally*/];
                case 9: return [3 /*break*/, 11];
                case 10:
                    updateChildren(root, []);
                    return [7 /*endfinally*/];
                case 11: return [2 /*return*/];
            }
        });
    },
    _a);
var DOMRenderer = /** @class */ (function (_super) {
    __extends(DOMRenderer, _super);
    function DOMRenderer() {
        return _super.call(this, env) || this;
    }
    return DOMRenderer;
}(Renderer));
var renderer = new DOMRenderer();

export { DOMRenderer, env, renderer };
//# sourceMappingURL=dom.js.map
