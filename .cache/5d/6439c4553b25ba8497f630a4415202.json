{"id":"node_modules/@bikeshaving/crank/esm/index.js","dependencies":[{"name":"/Users/ianschwartz/crank-boilerplate/node_modules/@bikeshaving/crank/esm/index.js.map","includedInParent":true,"mtime":1587136189624},{"name":"/Users/ianschwartz/crank-boilerplate/package.json","includedInParent":true,"mtime":1587136220963},{"name":"/Users/ianschwartz/crank-boilerplate/.babelrc","includedInParent":true,"mtime":1587136213417},{"name":"/Users/ianschwartz/crank-boilerplate/node_modules/@bikeshaving/crank/package.json","includedInParent":true,"mtime":1587136189624},{"name":"./_tslib-21ac4f0e.js","loc":{"line":1,"column":123},"parent":"/Users/ianschwartz/crank-boilerplate/node_modules/@bikeshaving/crank/esm/index.js","resolved":"/Users/ianschwartz/crank-boilerplate/node_modules/@bikeshaving/crank/esm/_tslib-21ac4f0e.js"},{"name":"@repeaterjs/repeater","loc":{"line":2,"column":40},"parent":"/Users/ianschwartz/crank-boilerplate/node_modules/@bikeshaving/crank/esm/index.js","resolved":"/Users/ianschwartz/crank-boilerplate/node_modules/@repeaterjs/repeater/lib/repeater.esm.js"},{"name":"event-target-shim","loc":{"line":3,"column":28},"parent":"/Users/ianschwartz/crank-boilerplate/node_modules/@bikeshaving/crank/esm/index.js","resolved":"/Users/ianschwartz/crank-boilerplate/node_modules/event-target-shim/dist/event-target-shim.js"},{"name":"./pledge-363d33da.js","loc":{"line":4,"column":48},"parent":"/Users/ianschwartz/crank-boilerplate/node_modules/@bikeshaving/crank/esm/index.js","resolved":"/Users/ianschwartz/crank-boilerplate/node_modules/@bikeshaving/crank/esm/pledge-363d33da.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearFrame = clearFrame;\nexports.createElement = createElement;\nexports.isComponentElement = isComponentElement;\nexports.isElement = isElement;\nexports.isIntrinsicElement = isIntrinsicElement;\nexports.isKeyedElement = isKeyedElement;\nexports.setFrame = setFrame;\nexports.Text = exports.Renderer = exports.Portal = exports.Fragment = exports.Default = exports.Copy = exports.Context = void 0;\n\nvar _tslib21ac4f0e = require(\"./_tslib-21ac4f0e.js\");\n\nvar _repeater = require(\"@repeaterjs/repeater\");\n\nvar _eventTargetShim = require(\"event-target-shim\");\n\nvar _pledge363d33da = require(\"./pledge-363d33da.js\");\n\nfunction normalizeOptions(options) {\n  var capture = false;\n  var passive;\n  var once;\n\n  if (typeof options === \"boolean\") {\n    capture = options;\n  } else if (options != null) {\n    capture = !!options.capture;\n    passive = options.passive;\n    once = options.once;\n  }\n\n  return {\n    capture: capture,\n    passive: passive,\n    once: once\n  };\n} // TODO: strongly typed events somehow\n\n\nvar CrankEventTarget =\n/** @class */\nfunction (_super) {\n  (0, _tslib21ac4f0e._)(CrankEventTarget, _super);\n\n  function CrankEventTarget(parent) {\n    var _this = _super.call(this) || this;\n\n    _this.parent = parent; // TODO: maybe use a helper class?\n    // we need a map from:\n    // type -> capture -> listener record\n    // for efficient querying\n\n    _this.listeners = [];\n    _this._delegates = new Set();\n    return _this;\n  }\n\n  Object.defineProperty(CrankEventTarget.prototype, \"delegates\", {\n    get: function () {\n      return this._delegates;\n    },\n    set: function (delegates) {\n      var e_1, _a, e_2, _b, e_3, _c, e_4, _d;\n\n      var _this = this;\n\n      var removed = new Set(Array.from(this._delegates).filter(function (d) {\n        return !delegates.has(d);\n      }));\n      var added = new Set(Array.from(delegates).filter(function (d) {\n        return !_this._delegates.has(d);\n      }));\n\n      try {\n        for (var removed_1 = (0, _tslib21ac4f0e.a)(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {\n          var delegate = removed_1_1.value;\n\n          try {\n            for (var _e = (e_2 = void 0, (0, _tslib21ac4f0e.a)(this.listeners)), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var listener = _f.value;\n              delegate.removeEventListener(listener.type, listener.callback, listener.options);\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (removed_1_1 && !removed_1_1.done && (_a = removed_1.return)) _a.call(removed_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      try {\n        for (var added_1 = (0, _tslib21ac4f0e.a)(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {\n          var delegate = added_1_1.value;\n\n          try {\n            for (var _g = (e_4 = void 0, (0, _tslib21ac4f0e.a)(this.listeners)), _h = _g.next(); !_h.done; _h = _g.next()) {\n              var listener = _h.value;\n              delegate.addEventListener(listener.type, listener.callback, listener.options);\n            }\n          } catch (e_4_1) {\n            e_4 = {\n              error: e_4_1\n            };\n          } finally {\n            try {\n              if (_h && !_h.done && (_d = _g.return)) _d.call(_g);\n            } finally {\n              if (e_4) throw e_4.error;\n            }\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (added_1_1 && !added_1_1.done && (_c = added_1.return)) _c.call(added_1);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      this._delegates = delegates;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CrankEventTarget.prototype.addEventListener = function (type, callback, options) {\n    var e_5, _a;\n\n    if (callback == null) {\n      return;\n    } else if (typeof callback === \"object\") {\n      throw new Error(\"Listener objects are not supported\");\n    }\n\n    options = normalizeOptions(options);\n    var record = {\n      type: type,\n      callback: callback,\n      options: options\n    };\n\n    if (options.once) {\n      var self_1 = this;\n\n      record.callback = function (ev) {\n        var result = callback.call(this, ev);\n        self_1.removeEventListener(record.type, record.callback, record.options);\n        return result;\n      };\n    }\n\n    if (record.type.slice(0, 6) !== \"crank.\") {\n      var idx = this.listeners.findIndex(function (record1) {\n        return record.type === record1.type && record.callback === record1.callback && record.options.capture === record1.options.capture;\n      });\n\n      if (idx <= -1) {\n        this.listeners.push(record);\n      }\n    }\n\n    try {\n      for (var _b = (0, _tslib21ac4f0e.a)(this.delegates), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var delegate = _c.value;\n        delegate.addEventListener(type, callback, options);\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    return _super.prototype.addEventListener.call(this, type, callback, options);\n  };\n\n  CrankEventTarget.prototype.removeEventListener = function (type, callback, options) {\n    var e_6, _a;\n\n    if (callback == null) {\n      return;\n    }\n\n    var capture = typeof options === \"boolean\" ? options : !!(options && options.capture);\n    var idx = this.listeners.findIndex(function (record) {\n      return record.type === type && record.callback === callback && record.options.capture === capture;\n    });\n    var record = this.listeners[idx];\n\n    if (record !== undefined) {\n      this.listeners.splice(idx, 1);\n    }\n\n    try {\n      for (var _b = (0, _tslib21ac4f0e.a)(this.delegates), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var delegate = _c.value;\n        delegate.removeEventListener(type, callback, options);\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n\n    return _super.prototype.removeEventListener.call(this, type, callback, options);\n  };\n\n  CrankEventTarget.prototype.clearEventListeners = function () {\n    var e_7, _a;\n\n    try {\n      for (var _b = (0, _tslib21ac4f0e.a)(this.listeners.slice()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var listener = _c.value;\n        this.removeEventListener(listener.type, listener.callback, listener.options);\n      }\n    } catch (e_7_1) {\n      e_7 = {\n        error: e_7_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_7) throw e_7.error;\n      }\n    }\n  }; // TODO: ev is any because event-target-shim has a weird dispatchEvent type\n\n\n  CrankEventTarget.prototype.dispatchEvent = function (ev) {\n    var continued = _super.prototype.dispatchEvent.call(this, ev);\n\n    if (continued && ev.bubbles && this.parent !== undefined) {\n      // TODO: implement event capturing\n      continued = this.parent.dispatchEvent(ev);\n    }\n\n    return continued;\n  };\n\n  return CrankEventTarget;\n}(_eventTargetShim.EventTarget);\n\nfunction isEventTarget(value) {\n  return value != null && typeof value.addEventListener === \"function\" && typeof value.removeEventListener === \"function\" && typeof value.dispatchEvent === \"function\";\n}\n\nvar _a;\n\nfunction isIterable(value) {\n  return value != null && typeof value[Symbol.iterator] === \"function\";\n}\n\nfunction isNonStringIterable(value) {\n  return typeof value !== \"string\" && isIterable(value);\n}\n\nfunction isIteratorOrAsyncIterator(value) {\n  return value != null && typeof value.next === \"function\";\n} // TODO: rename\n\n\nvar Default = Symbol.for(\"crank.Default\"); // TODO: rename\n\nexports.Default = Default;\nvar Text = Symbol.for(\"crank.Text\"); // TODO: We use any for symbol tags because typescript support for symbols is weak af.\n\nexports.Text = Text;\nvar Portal = Symbol.for(\"crank.Portal\");\nexports.Portal = Portal;\nvar Fragment = Symbol.for(\"crank.Fragment\");\nexports.Fragment = Fragment;\nvar Copy = Symbol(\"crank.Copy\");\nexports.Copy = Copy;\nvar ElementSigil = Symbol.for(\"crank.ElementSigil\");\n\nfunction isElement(value) {\n  return value != null && value[ElementSigil];\n}\n\nfunction isIntrinsicElement(value) {\n  return isElement(value) && typeof value.tag !== \"function\";\n}\n\nfunction isComponentElement(value) {\n  return isElement(value) && typeof value.tag === \"function\";\n}\n\nfunction isKeyedElement(value) {\n  return isElement(value) && value.key != null;\n}\n\nfunction createElement(tag, props) {\n  var _a;\n\n  props = Object.assign({}, props);\n  var key = props[\"crank-key\"];\n\n  if (key != null) {\n    delete props[\"crank-key\"];\n  }\n\n  if (arguments.length > 3) {\n    props.children = Array.from(arguments).slice(2);\n  } else if (arguments.length > 2) {\n    props.children = arguments[2];\n  }\n\n  return _a = {}, _a[ElementSigil] = true, _a.tag = tag, _a.props = props, _a.key = key, _a;\n}\n\nfunction toGuest(child) {\n  if (child == null || typeof child === \"boolean\") {\n    return undefined;\n  } else if (typeof child === \"string\" || isElement(child)) {\n    return child;\n  } else {\n    return child.toString();\n  }\n} // TODO: explain what this function does\n\n\nfunction chase(fn) {\n  var next = function () {};\n\n  return function chaseWrapper() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var result = fn.apply(this, args);\n    next(result);\n\n    if ((0, _pledge363d33da.i)(result)) {\n      var nextP = new Promise(function (resolve) {\n        return next = resolve;\n      });\n      return Promise.race([result, nextP]);\n    }\n\n    return result;\n  };\n}\n\nvar Link =\n/** @class */\nfunction () {\n  function Link() {}\n\n  Link.prototype.insertBefore = function (newLink, refLink) {\n    newLink.nextSibling = refLink;\n\n    if (refLink.previousSibling === undefined) {\n      newLink.previousSibling = undefined;\n      this.firstChild = newLink;\n    } else {\n      newLink.previousSibling = refLink.previousSibling;\n      refLink.previousSibling.nextSibling = newLink;\n    }\n\n    refLink.previousSibling = newLink;\n  };\n\n  Link.prototype.insertAfter = function (newLink, refLink) {\n    newLink.previousSibling = refLink;\n\n    if (refLink.nextSibling === undefined) {\n      newLink.nextSibling = undefined;\n      this.lastChild = newLink;\n    } else {\n      newLink.nextSibling = refLink.nextSibling;\n      refLink.nextSibling.previousSibling = newLink;\n    }\n\n    refLink.nextSibling = newLink;\n  };\n\n  Link.prototype.appendChild = function (link) {\n    if (this.lastChild === undefined) {\n      this.firstChild = link;\n      this.lastChild = link;\n      link.previousSibling = undefined;\n      link.nextSibling = undefined;\n    } else {\n      this.insertAfter(link, this.lastChild);\n    }\n  };\n\n  Link.prototype.removeChild = function (link) {\n    if (link.previousSibling === undefined) {\n      this.firstChild = link.nextSibling;\n    } else {\n      link.previousSibling.nextSibling = link.nextSibling;\n    }\n\n    if (link.nextSibling === undefined) {\n      this.lastChild = link.previousSibling;\n    } else {\n      link.nextSibling.previousSibling = link.previousSibling;\n    }\n  };\n\n  Link.prototype.replaceChild = function (newLink, refLink) {\n    this.insertBefore(newLink, refLink);\n    this.removeChild(refLink);\n  };\n\n  return Link;\n}();\n\nvar Host =\n/** @class */\nfunction (_super) {\n  (0, _tslib21ac4f0e._)(Host, _super);\n\n  function Host(parent, // TODO: Figure out a way to not have to pass in a renderer\n  renderer) {\n    var _this = _super.call(this) || this;\n\n    _this.publications = new Set(); // TODO: reduce the number of boolean properties\n\n    _this.updating = false;\n    _this.done = false;\n    _this.unmounted = false;\n    _this.independent = false;\n    _this.clock = 0; // TODO: clean up this monster\n\n    _this.updateChildren = chase(function updateChildren(children) {\n      var e_1, _a, e_2, _b;\n\n      var _this = this;\n\n      var host = this.firstChild;\n      var promises = [];\n      var hostsByKey;\n\n      if (children != null) {\n        if (!isNonStringIterable(children)) {\n          children = [children];\n        }\n\n        var _loop_1 = function (child) {\n          if (isNonStringIterable(child)) {\n            child = createElement(Fragment, null, child);\n          }\n\n          var guest = toGuest(child);\n          var tag = void 0;\n          var key = void 0;\n          var isNewHost = false;\n\n          if (isElement(guest)) {\n            tag = guest.tag;\n            key = guest.key;\n\n            if (hostsByKey !== undefined && hostsByKey.has(key)) {\n              // TODO: warn about a duplicate key\n              key = undefined;\n            }\n          }\n\n          if (key != null) {\n            var newHost = this_1.hostsByKey && this_1.hostsByKey.get(key);\n\n            if (newHost === undefined) {\n              newHost = new Host(this_1, this_1.renderer);\n              isNewHost = true;\n            } else {\n              this_1.hostsByKey.delete(key);\n\n              if (host !== newHost) {\n                this_1.removeChild(newHost);\n              }\n            }\n\n            if (host === undefined) {\n              this_1.appendChild(newHost);\n            } else if (host !== newHost) {\n              if (isKeyedElement(host.guest)) {\n                this_1.insertAfter(newHost, host);\n              } else {\n                this_1.insertBefore(newHost, host);\n              }\n            }\n\n            host = newHost;\n          } else if (host === undefined) {\n            host = new Host(this_1, this_1.renderer);\n            this_1.appendChild(host);\n            isNewHost = true;\n          } else if (host.key != null) {\n            var newHost = new Host(this_1, this_1.renderer);\n            this_1.insertAfter(newHost, host);\n            host = newHost;\n            isNewHost = true;\n          }\n\n          if (tag !== Copy) {\n            if (isNewHost || !host.unmounted && host.tag === tag) {\n              var updateP = host.update(guest);\n\n              if (updateP !== undefined) {\n                promises.push(updateP);\n              }\n            } else {\n              // replace the host with another one\n              var clock = host.clock++;\n              var newHost_1 = new Host(this_1, this_1.renderer);\n              newHost_1.clock = clock;\n              var updateP = newHost_1.update(guest);\n\n              if (updateP === undefined) {\n                host.unmount();\n                this_1.replaceChild(newHost_1, host);\n                host.replacedBy = newHost_1;\n              } else {\n                // TODO: unmount only when the host is ready to be replaced\n                host.unmount();\n                promises.push(updateP);\n                var host1_1 = host;\n                updateP.then(function () {\n                  if (host1_1.replacedBy === undefined) {\n                    _this.replaceChild(newHost_1, host1_1);\n\n                    host1_1.replacedBy = newHost_1;\n                  } else if (host1_1.replacedBy.replacedBy === undefined && host1_1.replacedBy.clock < newHost_1.clock) {\n                    _this.replaceChild(newHost_1, host1_1.replacedBy);\n\n                    host1_1.replacedBy = newHost_1;\n                  }\n                });\n              }\n            }\n          }\n\n          if (key !== undefined) {\n            if (hostsByKey === undefined) {\n              hostsByKey = new Map();\n            }\n\n            hostsByKey.set(key, host);\n          }\n\n          host = host.nextSibling;\n        };\n\n        var this_1 = this;\n\n        try {\n          for (var children_1 = (0, _tslib21ac4f0e.a)(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\n            var child = children_1_1.value;\n\n            _loop_1(child);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      } // unmounting excess hosts\n\n\n      while (host !== undefined) {\n        if (this.hostsByKey !== undefined && host.key !== undefined) {\n          this.hostsByKey.delete(host.key);\n        }\n\n        host.unmount();\n        var nextSibling = host.nextSibling;\n        this.removeChild(host);\n        host = nextSibling;\n      } // unmounting keyed hosts\n\n\n      if (this.hostsByKey) {\n        try {\n          for (var _c = (0, _tslib21ac4f0e.a)(this.hostsByKey.values()), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var host_1 = _d.value; // TODO: implement async unmount for keyed hosts\n\n            host_1.unmount();\n            this.removeChild(host_1);\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n\n      this.hostsByKey = hostsByKey; // TODO: can we move this somewhere else\n\n      if (promises.length) {\n        return Promise.all(promises).then(function () {\n          return void _this.commit();\n        }); // void :(\n      } else {\n        this.commit();\n      }\n    });\n    _this.parent = parent;\n    _this.renderer = renderer;\n    return _this;\n  }\n\n  Object.defineProperty(Host.prototype, \"tag\", {\n    // TODO: flatten these instead of storing guest\n    get: function () {\n      return isElement(this.guest) ? this.guest.tag : undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Host.prototype, \"key\", {\n    get: function () {\n      return isElement(this.guest) ? this.guest.key : undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Host.prototype, \"props\", {\n    get: function () {\n      return isElement(this.guest) ? this.guest.props : undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Host.prototype, \"childNodes\", {\n    get: function () {\n      if (this.cachedChildNodes !== undefined) {\n        return this.cachedChildNodes;\n      }\n\n      var buffer;\n      var childNodes = [];\n\n      for (var host = this.firstChild; host !== undefined; host = host.nextSibling) {\n        if (typeof host.node === \"string\") {\n          buffer = (buffer || \"\") + host.node;\n        } else if (host.tag !== Portal) {\n          if (buffer !== undefined) {\n            childNodes.push(buffer);\n            buffer = undefined;\n          }\n\n          if (host.node === undefined) {\n            childNodes.push.apply(childNodes, (0, _tslib21ac4f0e.b)(host.childNodes));\n          } else {\n            childNodes.push(host.node);\n          }\n        }\n      }\n\n      if (buffer !== undefined) {\n        childNodes.push(buffer);\n      }\n\n      if (this.ctx !== undefined && typeof this.tag === \"function\") {\n        // TODO: filter predicate type narrowing is not working\n        this.ctx.delegates = new Set(childNodes.filter(isEventTarget));\n      }\n\n      this.cachedChildNodes = childNodes;\n      return childNodes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Host.prototype, \"childNodeOrNodes\", {\n    get: function () {\n      if (this.childNodes.length > 1) {\n        return this.childNodes;\n      }\n\n      return this.childNodes[0];\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Host.prototype.update = function (guest) {\n    this.updating = true;\n\n    if (this.tag === undefined) {\n      if (isElement(guest)) {\n        this.ctx = new Context(this, this.parent && this.parent.ctx);\n\n        if (typeof guest.tag !== \"function\") {\n          this.intrinsic = this.renderer.intrinsicFor(guest.tag);\n        }\n      }\n    }\n\n    this.guest = guest;\n    return this.refresh();\n  };\n\n  Host.prototype.step = function (next) {\n    var _this = this;\n\n    if (this.ctx === undefined) {\n      throw new Error(\"Missing context\");\n    } else if (!isComponentElement(this.guest)) {\n      throw new Error(\"Non-component element as guest\");\n    }\n\n    if (this.iterator === undefined) {\n      this.ctx.clearEventListeners(); // TODO: can we have pledges take an executor to reduce error duplication\n\n      var value = void 0;\n\n      try {\n        value = this.guest.tag.call(this.ctx, this.guest.props);\n\n        if ((0, _pledge363d33da.i)(value)) {\n          value = Promise.resolve(value).catch(function (err) {\n            if (_this.parent === undefined) {\n              throw err;\n            }\n\n            _this.parent.catch(err);\n\n            return undefined;\n          });\n          return value;\n        }\n      } catch (err) {\n        if (this.parent === undefined) {\n          throw err;\n        }\n\n        this.parent.catch(err);\n        return;\n      }\n\n      if (isIteratorOrAsyncIterator(value)) {\n        this.iterator = value;\n      } else {\n        return value;\n      }\n    } else if (this.done) {\n      return;\n    }\n\n    var iteration; // TODO: figure out if we can have pledges take a callback to reduce duplication when catching events\n\n    try {\n      iteration = this.iterator.next(next);\n\n      if ((0, _pledge363d33da.i)(iteration)) {\n        iteration = iteration.catch(function (err) {\n          if (_this.parent === undefined) {\n            throw err;\n          }\n\n          _this.parent.catch(err);\n\n          return undefined;\n        });\n      }\n    } catch (err) {\n      if (this.parent === undefined) {\n        throw err;\n      }\n\n      this.parent.catch(err);\n      return;\n    }\n\n    if ((0, _pledge363d33da.i)(iteration)) {\n      this.independent = true;\n      return iteration.then(function (iteration) {\n        var updateP = new _pledge363d33da.P(iteration.value).then(function (child) {\n          return _this.updateChildren(child);\n        });\n        var next = new _pledge363d33da.P(updateP).then(function () {\n          return _this.childNodeOrNodes;\n        });\n\n        if (iteration.done) {\n          _this.done = true;\n        } else if (!_this.done) {\n          _this.pending = new Promise(function (resolve) {\n            return setFrame(resolve);\n          }).then(function () {\n            return _this.step(next);\n          });\n        }\n\n        return updateP;\n      });\n    }\n\n    if (iteration.done) {\n      this.done = true;\n    }\n\n    return new _pledge363d33da.P(iteration.value).then(function (child) {\n      return _this.updateChildren(child);\n    });\n  };\n\n  Host.prototype.run = function () {\n    var _this = this;\n\n    if (this.pending === undefined) {\n      var next = this.iterator === undefined ? undefined : this.childNodeOrNodes;\n      var step = this.step(next);\n\n      if (this.iterator === undefined) {\n        if ((0, _pledge363d33da.i)(step)) {\n          this.pending = Promise.resolve(step).finally(function () {\n            _this.pending = _this.enqueued;\n            _this.enqueued = undefined;\n          });\n          return Promise.resolve(step).then(function (child) {\n            return _this.updateChildren(child);\n          });\n        } else {\n          return this.updateChildren(step);\n        }\n      } else if ((0, _pledge363d33da.i)(step)) {\n        this.pending = Promise.resolve(step);\n\n        if (!this.independent) {\n          this.pending.finally(function () {\n            _this.pending = _this.enqueued;\n            _this.enqueued = undefined;\n          });\n        }\n      }\n\n      return this.pending;\n    } else if (this.independent) {\n      return this.pending;\n    } else if (this.enqueued === undefined) {\n      this.enqueued = this.pending.then(function () {\n        return _this.step(_this.childNodeOrNodes);\n      }, function () {\n        return _this.step(_this.childNodeOrNodes);\n      });\n\n      if (this.iterator === undefined) {\n        this.enqueued = this.enqueued.then(function (child) {\n          return _this.updateChildren(child);\n        });\n      }\n\n      this.enqueued.finally(function () {\n        _this.pending = _this.enqueued;\n        _this.enqueued = undefined;\n      });\n    }\n\n    return this.enqueued;\n  };\n\n  Host.prototype.refresh = function () {\n    var e_3, _a;\n\n    if (this.unmounted) {\n      return;\n    } else if (this.tag !== undefined) {\n      try {\n        for (var _b = (0, _tslib21ac4f0e.a)(this.publications), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var pub = _c.value;\n          pub.push(this.props);\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      if (typeof this.tag === \"function\") {\n        return this.run();\n      } else {\n        return this.updateChildren(this.props && this.props.children);\n      }\n    } else if (typeof this.guest === \"string\") {\n      this.node = this.renderer.text(this.guest);\n    } else {\n      this.node = undefined;\n    }\n  };\n\n  Host.prototype.commit = function () {\n    this.cachedChildNodes = undefined;\n\n    if (isElement(this.guest)) {\n      if (typeof this.guest.tag === \"function\") {\n        if (!this.updating && this.parent !== undefined) {\n          // TODO: batch this per microtask\n          this.parent.commit();\n        }\n      } else {\n        if (this.committer === undefined && this.intrinsic !== undefined && this.ctx !== undefined) {\n          var value = this.intrinsic.call(this.ctx, this.guest.props);\n\n          if (isIteratorOrAsyncIterator(value)) {\n            this.committer = value;\n          } else {\n            this.node = value;\n          }\n        }\n\n        if (this.committer !== undefined) {\n          var iteration = this.committer.next();\n          this.node = iteration.value;\n\n          if (iteration.done) {\n            this.committer = undefined;\n            this.intrinsic = undefined;\n          }\n        }\n\n        if (this.node == null && this.parent !== undefined) {\n          this.parent.commit();\n        }\n      }\n    }\n\n    this.updating = false;\n  };\n\n  Host.prototype.catch = function (reason) {\n    var _this = this;\n\n    if (this.iterator === undefined || this.iterator.throw === undefined || this.done) {\n      if (this.parent === undefined) {\n        throw reason;\n      }\n\n      this.parent.catch(reason);\n    } else {\n      try {\n        // TODO: catch async errors too\n        var iteration = this.iterator.throw(reason);\n        new _pledge363d33da.P(iteration).then(function (iteration) {\n          if (iteration.done) {\n            _this.done = true;\n          }\n\n          _this.updateChildren(iteration.value);\n        });\n      } catch (err) {\n        if (this.parent === undefined) {\n          throw err;\n        }\n\n        this.parent.catch(err);\n      }\n    }\n  };\n\n  Host.prototype.unmount = function () {\n    var e_4, _a;\n\n    try {\n      for (var _b = (0, _tslib21ac4f0e.a)(this.publications), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var pub = _c.value;\n        pub.stop();\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    } // TODO: await the return if the host is keyed and commit the parent\n\n\n    if (!this.done) {\n      if (this.iterator !== undefined && this.iterator.return) {\n        this.iterator.return();\n      }\n\n      if (this.committer && this.committer.return) {\n        this.committer.return();\n      }\n    }\n\n    this.unmounted = true;\n    this.committer = undefined;\n    this.iterator = undefined;\n    this.updating = false;\n    this.unmountChildren();\n  };\n\n  Host.prototype.unmountChildren = function () {\n    var host = this.firstChild;\n\n    while (host !== undefined) {\n      // TODO: catch errors\n      host.unmount();\n      host = host.nextSibling;\n    }\n  };\n\n  return Host;\n}(Link);\n\nvar hosts = new WeakMap();\n\nvar Context =\n/** @class */\nfunction (_super) {\n  (0, _tslib21ac4f0e._)(Context, _super);\n\n  function Context(host, parent) {\n    var _this = _super.call(this, parent) || this;\n\n    hosts.set(_this, host);\n    return _this;\n  }\n\n  Object.defineProperty(Context.prototype, \"node\", {\n    get: function () {\n      return hosts.get(this).node;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Context.prototype, \"childNodes\", {\n    get: function () {\n      return hosts.get(this).childNodes;\n    },\n    enumerable: true,\n    configurable: true\n  }); // TODO: throw an error if props are pulled multiple times without a yield\n\n  Context.prototype[Symbol.iterator] = function () {\n    var host;\n    return (0, _tslib21ac4f0e.c)(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          host = hosts.get(this);\n          _a.label = 1;\n\n        case 1:\n          return [4\n          /*yield*/\n          , host.props];\n\n        case 2:\n          _a.sent();\n\n          return [3\n          /*break*/\n          , 1];\n\n        case 3:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  }; // TODO: throw an error if props are pulled multiple times without a yield\n\n\n  Context.prototype[Symbol.asyncIterator] = function () {\n    var _this = this;\n\n    var host = hosts.get(this);\n    return new _repeater.Repeater(function (push, stop) {\n      return (0, _tslib21ac4f0e.d)(_this, void 0, void 0, function () {\n        var pub;\n        return (0, _tslib21ac4f0e.c)(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              push(host.props);\n              pub = {\n                push: push,\n                stop: stop\n              };\n              host.publications.add(pub);\n              return [4\n              /*yield*/\n              , stop];\n\n            case 1:\n              _a.sent();\n\n              host.publications.delete(pub);\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }, new _repeater.SlidingBuffer(1));\n  }; // TODO: throw or warn if called on an unmounted component?\n\n\n  Context.prototype.refresh = function () {\n    var host = hosts.get(this);\n    return host.refresh();\n  };\n\n  return Context;\n}(CrankEventTarget);\n\nexports.Context = Context;\nvar defaultEnv = (_a = {}, _a[Default] = function (tag) {\n  throw new Error(\"Environment did not provide an intrinsic for \" + tag);\n}, _a[Portal] = function () {\n  throw new Error(\"Environment did not provide an intrinsic for Portal\");\n}, _a[Fragment] = function () {\n  return undefined; // void :(\n}, _a);\n\nfunction setFrame(callback) {\n  if (requestAnimationFrame !== undefined) {\n    return requestAnimationFrame(callback);\n  } else if (setImmediate !== undefined) {\n    return setImmediate(function () {\n      return callback(Date.now());\n    });\n  } else {\n    return setTimeout(function () {\n      return callback(Date.now());\n    });\n  }\n}\n\nfunction clearFrame(id) {\n  if (requestAnimationFrame !== undefined) {\n    cancelAnimationFrame(id);\n  } else if (setImmediate !== undefined) {\n    clearImmediate(id);\n  } else {\n    clearTimeout(id);\n  }\n}\n\nvar Renderer =\n/** @class */\nfunction () {\n  function Renderer(env) {\n    this.cache = new WeakMap();\n    this.env = (0, _tslib21ac4f0e.f)({}, defaultEnv);\n\n    if (env) {\n      this.extend(env);\n    }\n  }\n\n  Renderer.prototype.getOrCreateHost = function (root) {\n    var host;\n\n    if (root !== undefined) {\n      host = this.cache.get(root);\n    }\n\n    if (host === undefined) {\n      host = new Host(undefined, this);\n\n      if (root !== undefined) {\n        this.cache.set(root, host);\n      }\n    }\n\n    return host;\n  };\n\n  Renderer.prototype.extend = function (env) {\n    var e_5, _a;\n\n    if (env[Default] != null) {\n      this.env[Default] = env[Default];\n    }\n\n    if (env[Portal] != null) {\n      this.env[Portal] = env[Portal];\n    }\n\n    try {\n      for (var _b = (0, _tslib21ac4f0e.a)(Object.entries(env)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = (0, _tslib21ac4f0e.e)(_c.value, 2),\n            tag = _d[0],\n            value = _d[1];\n\n        if (value != null) {\n          this.env[tag] = value;\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n  };\n\n  Renderer.prototype.intrinsicFor = function (tag) {\n    if (this.env[tag]) {\n      return this.env[tag];\n    } else if (typeof tag === \"string\") {\n      return this.env[Default](tag);\n    } else {\n      throw new Error(\"Unknown tag \" + tag.toString());\n    }\n  };\n\n  Renderer.prototype.text = function (text) {\n    if (this.env[Text] !== undefined) {\n      // TODO: remove non-null assertion when typescript gets its shit together with symbols\n      return this.env[Text](text);\n    }\n\n    return text;\n  };\n\n  Renderer.prototype.render = function (child, root) {\n    if (!isElement(child) || child.tag !== Portal) {\n      child = createElement(Portal, {\n        root: root\n      }, child);\n    }\n\n    var host = this.getOrCreateHost(root);\n    var p;\n\n    if (child == null) {\n      p = host.unmount();\n    } else {\n      p = host.update(toGuest(child));\n    }\n\n    return new _pledge363d33da.P(p).then(function () {\n      return host.ctx;\n    });\n  };\n\n  return Renderer;\n}();\n\nexports.Renderer = Renderer;"},"sourceMaps":{"js":{"mappings":[],"sources":{},"lineCount":null}},"error":null,"hash":"1158ea84c65571ce1ecc6829cd1a6412","cacheData":{"env":{}}}