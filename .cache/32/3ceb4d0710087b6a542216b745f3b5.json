{"id":"node_modules/@repeaterjs/repeater/lib/repeater.esm.js","dependencies":[{"name":"/Users/ianschwartz/crank-boilerplate/node_modules/@repeaterjs/repeater/lib/repeater.esm.js.map","includedInParent":true,"mtime":1587136189622},{"name":"/Users/ianschwartz/crank-boilerplate/package.json","includedInParent":true,"mtime":1587136220963},{"name":"/Users/ianschwartz/crank-boilerplate/.babelrc","includedInParent":true,"mtime":1587136213417},{"name":"/Users/ianschwartz/crank-boilerplate/node_modules/@repeaterjs/repeater/package.json","includedInParent":true,"mtime":1587136189622}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SlidingBuffer = exports.RepeaterOverflowError = exports.Repeater = exports.MAX_QUEUE_LENGTH = exports.FixedBuffer = exports.DroppingBuffer = void 0;\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nfunction __values(o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n}\n\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n      i,\n      q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n}\n\nvar FixedBuffer =\n/** @class */\nfunction () {\n  function FixedBuffer(capacity) {\n    this.capacity = capacity;\n    this.arr = [];\n\n    if (capacity < 0) {\n      throw new RangeError(\"FixedBuffer capacity cannot be less than zero\");\n    }\n  }\n\n  Object.defineProperty(FixedBuffer.prototype, \"empty\", {\n    get: function () {\n      return this.arr.length === 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FixedBuffer.prototype, \"full\", {\n    get: function () {\n      return this.arr.length >= this.capacity;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  FixedBuffer.prototype.add = function (value) {\n    if (this.full) {\n      throw new Error(\"Buffer full\");\n    } else {\n      this.arr.push(value);\n    }\n  };\n\n  FixedBuffer.prototype.remove = function () {\n    if (this.empty) {\n      throw new Error(\"Buffer empty\");\n    }\n\n    return this.arr.shift();\n  };\n\n  return FixedBuffer;\n}(); // TODO: use a circular buffer here\n\n\nexports.FixedBuffer = FixedBuffer;\n\nvar SlidingBuffer =\n/** @class */\nfunction () {\n  function SlidingBuffer(capacity) {\n    this.capacity = capacity;\n    this.arr = [];\n    this.full = false;\n\n    if (capacity <= 0) {\n      throw new RangeError(\"SlidingBuffer capacity cannot be less than or equal to zero\");\n    }\n  }\n\n  Object.defineProperty(SlidingBuffer.prototype, \"empty\", {\n    get: function () {\n      return this.arr.length === 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SlidingBuffer.prototype.add = function (value) {\n    while (this.arr.length >= this.capacity) {\n      this.arr.shift();\n    }\n\n    this.arr.push(value);\n  };\n\n  SlidingBuffer.prototype.remove = function () {\n    if (this.empty) {\n      throw new Error(\"Buffer empty\");\n    }\n\n    return this.arr.shift();\n  };\n\n  return SlidingBuffer;\n}();\n\nexports.SlidingBuffer = SlidingBuffer;\n\nvar DroppingBuffer =\n/** @class */\nfunction () {\n  function DroppingBuffer(capacity) {\n    this.capacity = capacity;\n    this.arr = [];\n    this.full = false;\n\n    if (capacity <= 0) {\n      throw new RangeError(\"DroppingBuffer capacity cannot be less than or equal to zero\");\n    }\n  }\n\n  Object.defineProperty(DroppingBuffer.prototype, \"empty\", {\n    get: function () {\n      return this.arr.length === 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  DroppingBuffer.prototype.add = function (value) {\n    if (this.arr.length < this.capacity) {\n      this.arr.push(value);\n    }\n  };\n\n  DroppingBuffer.prototype.remove = function () {\n    if (this.empty) {\n      throw new Error(\"Buffer empty\");\n    }\n\n    return this.arr.shift();\n  };\n\n  return DroppingBuffer;\n}();\n\nexports.DroppingBuffer = DroppingBuffer;\nvar MAX_QUEUE_LENGTH = 1024;\nexports.MAX_QUEUE_LENGTH = MAX_QUEUE_LENGTH;\n\nvar NOOP = function () {};\n\nfunction isPromiseLike(value) {\n  return value != null && typeof value.then === \"function\";\n}\n\nfunction swallow(value) {\n  if (isPromiseLike(value)) {\n    Promise.resolve(value).catch(NOOP);\n  }\n}\n\nvar RepeaterOverflowError =\n/** @class */\nfunction (_super) {\n  __extends(RepeaterOverflowError, _super);\n\n  function RepeaterOverflowError(message) {\n    var _newTarget = this.constructor;\n\n    var _this = _super.call(this, message) || this;\n\n    Object.defineProperty(_this, \"name\", {\n      value: \"RepeaterOverflowError\",\n      enumerable: false\n    });\n\n    if (typeof Object.setPrototypeOf === \"function\") {\n      Object.setPrototypeOf(_this, _newTarget.prototype);\n    } else {\n      _this.__proto__ = _newTarget.prototype;\n    }\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(_this, _this.constructor);\n    }\n\n    return _this;\n  }\n\n  return RepeaterOverflowError;\n}(Error);\n/**\r\n * The functionality for repeaters is implemented in this helper class and\r\n * hidden using a private WeakMap to make repeaters themselves opaque and\r\n * maximally compatible with async generators.\r\n */\n\n\nexports.RepeaterOverflowError = RepeaterOverflowError;\n\nvar RepeaterController =\n/** @class */\nfunction () {\n  function RepeaterController(executor, buffer) {\n    this.executor = executor;\n    this.buffer = buffer;\n    this.state = 0\n    /* Initial */\n    ; // pushQueue and pullQueue will never both contain operations at the same time.\n\n    this.pushQueue = [];\n    this.pullQueue = [];\n    this.onnext = NOOP;\n    this.onstop = NOOP;\n  }\n  /**\r\n   * This method runs synchronously the first time next is called.\r\n   *\r\n   * Advances state to RepeaterState.Started\r\n   */\n\n\n  RepeaterController.prototype.execute = function () {\n    var _this = this;\n\n    if (this.state >= 1\n    /* Started */\n    ) {\n        return;\n      }\n\n    this.state = 1\n    /* Started */\n    ;\n    var push = this.push.bind(this);\n    var stop = this.stop.bind(this);\n    {\n      var stopP = new Promise(function (resolve) {\n        return _this.onstop = resolve;\n      });\n      stop.then = stopP.then.bind(stopP);\n      stop.catch = stopP.catch.bind(stopP);\n      stop.finally = stopP.finally.bind(stopP);\n    }\n\n    try {\n      this.execution = Promise.resolve(this.executor(push, stop));\n    } catch (err) {\n      // sync err in executor\n      this.execution = Promise.reject(err);\n    } // We don’t have to call this.stop with the error because all that does is\n    // reassign this.execution with the rejection.\n\n\n    this.execution.catch(function () {\n      return _this.stop();\n    });\n  };\n  /**\r\n   * A helper method which builds IteratorResult objects from values.  This\r\n   * method prevents types of Repeater<Promise<any>>, where the value property\r\n   * is a promise, and mimics the promise unwrapping behavior of async\r\n   * generators, where yield is equivalent to yield await.\r\n   */\n\n\n  RepeaterController.prototype.unwrap = function (value) {\n    var _this = this;\n\n    var done = this.state >= 3\n    /* Finished */\n    ;\n    return Promise.resolve(value).then(function (value) {\n      if (!done && _this.state >= 4\n      /* Rejected */\n      ) {\n          return _this.consume().then(function (value) {\n            return {\n              value: value,\n              done: true\n            };\n          });\n        }\n\n      return {\n        value: value,\n        done: done\n      };\n    });\n  };\n  /**\r\n   * A helper method used to mimic the behavior of async generators where the\r\n   * final result or any error are consumed, so that further calls to next,\r\n   * return or throw return { value: undefined, done: true }.\r\n   */\n\n\n  RepeaterController.prototype.consume = function () {\n    var err = this.err;\n    var execution = Promise.resolve(this.execution).then(function (value) {\n      if (err != null) {\n        throw err;\n      }\n\n      return value;\n    });\n    this.err = undefined;\n    this.execution = execution.then(function () {\n      return undefined;\n    }, function () {\n      return undefined;\n    });\n    return this.pending === undefined ? execution : this.pending.then(function () {\n      return execution;\n    });\n  };\n  /**\r\n   * The difference between stopping a repeater vs finishing a repeater is that\r\n   * stopping a repeater allows next to continue to drain values from the\r\n   * pushQueue and buffer, while finishing a repeater will clear all pending\r\n   * values and end iteration immediately. Once, a repeater is finished, all\r\n   * results will have the done property set to true.\r\n   *\r\n   * Advances state to RepeaterState.Finished\r\n   */\n\n\n  RepeaterController.prototype.finish = function () {\n    if (this.state >= 3\n    /* Finished */\n    ) {\n        return;\n      }\n\n    if (this.state < 2\n    /* Stopped */\n    ) {\n        this.stop();\n      }\n\n    this.state = 3\n    /* Finished */\n    ;\n    this.pushQueue = [];\n    this.buffer = new FixedBuffer(0);\n  };\n  /**\r\n   * Called when a promise passed to push rejects, or when a push call is\r\n   * unhandled.\r\n   *\r\n   * Advances state to RepeaterState.Rejected\r\n   */\n\n\n  RepeaterController.prototype.reject = function () {\n    if (this.state >= 4\n    /* Rejected */\n    ) {\n        return;\n      }\n\n    if (this.state < 3\n    /* Finished */\n    ) {\n        this.finish();\n      }\n\n    this.state = 4\n    /* Rejected */\n    ;\n  };\n  /**\r\n   * This method is bound and passed to the executor as the push argument.\r\n   */\n\n\n  RepeaterController.prototype.push = function (value) {\n    var _this = this;\n\n    swallow(value);\n\n    if (this.pushQueue.length >= MAX_QUEUE_LENGTH) {\n      throw new RepeaterOverflowError(\"No more than \" + MAX_QUEUE_LENGTH + \" pending calls to push are allowed on a single repeater.\");\n    } else if (this.state >= 2\n    /* Stopped */\n    ) {\n        return Promise.resolve(undefined);\n      }\n\n    var valueP = this.pending === undefined ? Promise.resolve(value) : this.pending.then(function () {\n      return value;\n    });\n    valueP = valueP.catch(function (err) {\n      if (_this.state < 2\n      /* Stopped */\n      ) {\n          _this.err = err;\n        }\n\n      _this.reject(); // Explicitly return undefined to avoid typescript’s horrible void type\n\n\n      return undefined;\n    });\n    var next;\n\n    if (this.pullQueue.length) {\n      var pull = this.pullQueue.shift();\n      pull.resolve(this.unwrap(valueP));\n\n      if (this.pullQueue.length) {\n        next = Promise.resolve(this.pullQueue[0].value);\n      } else {\n        next = new Promise(function (resolve) {\n          return _this.onnext = resolve;\n        });\n      }\n    } else if (!this.buffer.full) {\n      this.buffer.add(valueP);\n      next = Promise.resolve(undefined);\n    } else {\n      next = new Promise(function (resolve) {\n        _this.pushQueue.push({\n          resolve: resolve,\n          value: valueP\n        });\n      });\n    } // This method of catching unhandled rejections is adapted from\n    // https://stackoverflow.com/a/57792542/1825413\n\n\n    var floating = true;\n    var err;\n    var unhandled = next.catch(function (err1) {\n      if (floating) {\n        err = err1;\n      } // Explicitly return undefined to avoid typescript’s horrible void type\n\n\n      return undefined;\n    });\n\n    next.then = function (onFulfilled, onRejected) {\n      floating = false;\n      return Promise.prototype.then.call(this, onFulfilled, onRejected);\n    };\n\n    this.pending = valueP.then(function () {\n      return unhandled;\n    }).then(function () {\n      if (err != null) {\n        _this.err = err;\n\n        _this.reject();\n      } // Explicitly return undefined to avoid typescript’s horrible void type\n\n\n      return undefined;\n    });\n    return next;\n  };\n  /**\r\n   * This method is bound and passed to the executor as the stop argument.\r\n   *\r\n   * Advances state to RepeaterState.Stopped\r\n   */\n\n\n  RepeaterController.prototype.stop = function (err) {\n    var e_1, _a, e_2, _b;\n\n    var _this = this;\n\n    if (this.state >= 2\n    /* Stopped */\n    ) {\n        return;\n      }\n\n    this.state = 2\n    /* Stopped */\n    ;\n    this.onnext();\n    this.onstop();\n\n    if (this.err == null) {\n      this.err = err;\n    }\n\n    try {\n      for (var _c = __values(this.pushQueue), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var push = _d.value;\n        push.resolve();\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    } // If the pullQueue contains operations, the pushQueue and buffer are both\n    // necessarily empty, so we don‘t have to worry about this.finish clearing\n    // the pushQueue or buffer.\n\n\n    if (this.pullQueue.length) {\n      this.finish();\n\n      try {\n        for (var _e = __values(this.pullQueue), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var pull = _f.value;\n          var execution = this.pending === undefined ? this.consume() : this.pending.then(function () {\n            return _this.consume();\n          });\n          pull.resolve(this.unwrap(execution));\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n\n    this.pullQueue = [];\n  };\n\n  RepeaterController.prototype.next = function (value) {\n    var _this = this;\n\n    swallow(value);\n\n    if (this.pullQueue.length >= MAX_QUEUE_LENGTH) {\n      throw new RepeaterOverflowError(\"No more than \" + MAX_QUEUE_LENGTH + \" pending calls to Repeater.prototype.next are allowed on a single repeater.\");\n    }\n\n    if (this.state <= 0\n    /* Initial */\n    ) {\n        this.execute();\n      }\n\n    this.onnext(value);\n\n    if (!this.buffer.empty) {\n      var result = this.unwrap(this.buffer.remove());\n\n      if (this.pushQueue.length) {\n        var push = this.pushQueue.shift();\n        this.buffer.add(push.value);\n        this.onnext = push.resolve;\n      }\n\n      return result;\n    } else if (this.pushQueue.length) {\n      var push = this.pushQueue.shift();\n      this.onnext = push.resolve;\n      return this.unwrap(push.value);\n    } else if (this.state >= 2\n    /* Stopped */\n    ) {\n        this.finish();\n        return this.unwrap(this.consume());\n      }\n\n    return new Promise(function (resolve) {\n      return _this.pullQueue.push({\n        resolve: resolve,\n        value: value\n      });\n    });\n  };\n\n  RepeaterController.prototype.return = function (value) {\n    swallow(value);\n    this.finish();\n    this.execution = Promise.resolve(this.execution).then(function () {\n      return value;\n    });\n    return this.unwrap(this.consume());\n  };\n\n  RepeaterController.prototype.throw = function (err) {\n    if (this.state <= 0\n    /* Initial */\n    || this.state >= 2\n    /* Stopped */\n    || !this.buffer.empty) {\n      this.finish();\n\n      if (this.err == null) {\n        this.err = err;\n      }\n\n      return this.unwrap(this.consume());\n    }\n\n    return this.next(Promise.reject(err));\n  };\n\n  RepeaterController.prototype[Symbol.asyncIterator] = function () {\n    return this;\n  };\n\n  return RepeaterController;\n}();\n\nvar controllers = new WeakMap(); // We do not export any types which use >=3.6 IteratorResult, AsyncIterator or\n// AsyncGenerator types. This allows the code to be used with older versions of\n// typescript. We cannot implement `AsyncIterator` or `AsyncIterableIterator`\n// here because the default types are busted as hell.\n//\n// TODO: use typesVersions to ship stricter types.\n\nvar Repeater =\n/** @class */\nfunction () {\n  function Repeater(executor, buffer) {\n    if (buffer === void 0) {\n      buffer = new FixedBuffer(0);\n    }\n\n    controllers.set(this, new RepeaterController(executor, buffer));\n  }\n\n  Repeater.prototype.next = function (value) {\n    var controller = controllers.get(this);\n\n    if (controller === undefined) {\n      throw new Error(\"RepeaterController missing from controllers WeakMap\");\n    }\n\n    return controller.next(value);\n  };\n\n  Repeater.prototype.return = function (value) {\n    var controller = controllers.get(this);\n\n    if (controller === undefined) {\n      throw new Error(\"RepeaterController missing from controllers WeakMap\");\n    }\n\n    return controller.return(value);\n  };\n\n  Repeater.prototype.throw = function (err) {\n    var controller = controllers.get(this);\n\n    if (controller === undefined) {\n      throw new Error(\"RepeaterController missing from controllers WeakMap\");\n    }\n\n    return controller.throw(err);\n  };\n\n  Repeater.prototype[Symbol.asyncIterator] = function () {\n    return this;\n  };\n\n  Repeater.race = race;\n  Repeater.merge = merge;\n  Repeater.zip = zip;\n  Repeater.latest = latest;\n  return Repeater;\n}();\n\nexports.Repeater = Repeater;\n\nfunction isAsyncIterable(value) {\n  return value != null && typeof value[Symbol.asyncIterator] === \"function\";\n}\n\nfunction isIterable(value) {\n  return value != null && typeof value[Symbol.iterator] === \"function\";\n}\n\nfunction asyncIterators(contenders, options) {\n  var e_3, _a;\n\n  var yieldValues = options.yieldValues,\n      returnValues = options.returnValues;\n  var iters = [];\n\n  var _loop_1 = function (contender) {\n    if (isAsyncIterable(contender)) {\n      iters.push(contender[Symbol.asyncIterator]());\n    } else if (isIterable(contender)) {\n      var iter_1 = contender[Symbol.iterator]();\n      iters.push(function syncToAsyncIterator() {\n        return __asyncGenerator(this, arguments, function syncToAsyncIterator_1() {\n          var result;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                _a.trys.push([0,, 6, 7]);\n\n                result = iter_1.next();\n                _a.label = 1;\n\n              case 1:\n                if (!!result.done) return [3\n                /*break*/\n                , 4];\n                return [4\n                /*yield*/\n                , __await(result.value)];\n\n              case 2:\n                return [4\n                /*yield*/\n                , _a.sent()];\n\n              case 3:\n                _a.sent();\n\n                result = iter_1.next();\n                return [3\n                /*break*/\n                , 1];\n\n              case 4:\n                return [4\n                /*yield*/\n                , __await(result.value)];\n\n              case 5:\n                return [2\n                /*return*/\n                , _a.sent()];\n\n              case 6:\n                iter_1.return && iter_1.return();\n                return [7\n                /*endfinally*/\n                ];\n\n              case 7:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      }());\n    } else {\n      iters.push(function valueToAsyncIterator() {\n        return __asyncGenerator(this, arguments, function valueToAsyncIterator_1() {\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                if (!yieldValues) return [3\n                /*break*/\n                , 3];\n                return [4\n                /*yield*/\n                , __await(contender)];\n\n              case 1:\n                return [4\n                /*yield*/\n                , _a.sent()];\n\n              case 2:\n                _a.sent();\n\n                _a.label = 3;\n\n              case 3:\n                if (!returnValues) return [3\n                /*break*/\n                , 5];\n                return [4\n                /*yield*/\n                , __await(contender)];\n\n              case 4:\n                return [2\n                /*return*/\n                , _a.sent()];\n\n              case 5:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      }());\n    }\n  };\n\n  try {\n    for (var contenders_1 = __values(contenders), contenders_1_1 = contenders_1.next(); !contenders_1_1.done; contenders_1_1 = contenders_1.next()) {\n      var contender = contenders_1_1.value;\n\n      _loop_1(contender);\n    }\n  } catch (e_3_1) {\n    e_3 = {\n      error: e_3_1\n    };\n  } finally {\n    try {\n      if (contenders_1_1 && !contenders_1_1.done && (_a = contenders_1.return)) _a.call(contenders_1);\n    } finally {\n      if (e_3) throw e_3.error;\n    }\n  }\n\n  return iters;\n}\n\nfunction race(contenders) {\n  var _this = this;\n\n  var iters = asyncIterators(contenders, {\n    returnValues: true\n  });\n  return new Repeater(function (push, stop) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var stopped, returned, results, results_1, results_1_1, result_1, result;\n\n      var e_4, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!iters.length) {\n              stop();\n              return [2\n              /*return*/\n              ];\n            }\n\n            stopped = false;\n            stop.then(function () {\n              return stopped = true;\n            });\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1,, 7, 9]);\n\n            _b.label = 2;\n\n          case 2:\n            if (!!stopped) return [3\n            /*break*/\n            , 6];\n            results = iters.map(function (iter) {\n              return iter.next();\n            });\n\n            try {\n              for (results_1 = (e_4 = void 0, __values(results)), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {\n                result_1 = results_1_1.value;\n                Promise.resolve(result_1).then(function (result) {\n                  if (result.done && !stopped) {\n                    stop();\n                    stopped = true;\n                    returned = result.value;\n                  }\n                }, function (err) {\n                  return stop(err);\n                });\n              }\n            } catch (e_4_1) {\n              e_4 = {\n                error: e_4_1\n              };\n            } finally {\n              try {\n                if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);\n              } finally {\n                if (e_4) throw e_4.error;\n              }\n            }\n\n            return [4\n            /*yield*/\n            , Promise.race(__spread([stop], results))];\n\n          case 3:\n            result = _b.sent();\n            if (!(result !== undefined && !result.done)) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , push(result.value)];\n\n          case 4:\n            _b.sent();\n\n            _b.label = 5;\n\n          case 5:\n            return [3\n            /*break*/\n            , 2];\n\n          case 6:\n            return [2\n            /*return*/\n            , returned];\n\n          case 7:\n            stop();\n            return [4\n            /*yield*/\n            , Promise.race(iters.map(function (iter) {\n              return iter.return && iter.return();\n            }))];\n\n          case 8:\n            _b.sent();\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 9:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  });\n}\n\nfunction merge(contenders) {\n  var _this = this;\n\n  var iters = asyncIterators(contenders, {\n    yieldValues: true\n  });\n  return new Repeater(function (push, stop) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var stopped, returned;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!iters.length) {\n              stop();\n              return [2\n              /*return*/\n              ];\n            }\n\n            stopped = false;\n            stop.then(function () {\n              return stopped = true;\n            });\n            return [4\n            /*yield*/\n            , Promise.all(iters.map(function (iter) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var result, _a;\n\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      _b.trys.push([0,, 6, 9]);\n\n                      _b.label = 1;\n\n                    case 1:\n                      if (!!stopped) return [3\n                      /*break*/\n                      , 5];\n                      return [4\n                      /*yield*/\n                      , Promise.race([iter.next(), stop])];\n\n                    case 2:\n                      result = _b.sent();\n                      if (!(result !== undefined)) return [3\n                      /*break*/\n                      , 4];\n\n                      if (result.done) {\n                        returned = result.value;\n                        return [2\n                        /*return*/\n                        ];\n                      }\n\n                      return [4\n                      /*yield*/\n                      , push(result.value)];\n\n                    case 3:\n                      _b.sent();\n\n                      _b.label = 4;\n\n                    case 4:\n                      return [3\n                      /*break*/\n                      , 1];\n\n                    case 5:\n                      return [3\n                      /*break*/\n                      , 9];\n\n                    case 6:\n                      _a = iter.return;\n                      if (!_a) return [3\n                      /*break*/\n                      , 8];\n                      return [4\n                      /*yield*/\n                      , iter.return()];\n\n                    case 7:\n                      _a = _b.sent();\n                      _b.label = 8;\n\n                    case 8:\n                      return [7\n                      /*endfinally*/\n                      ];\n\n                    case 9:\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            }))];\n\n          case 1:\n            _a.sent();\n\n            stop();\n            return [2\n            /*return*/\n            , returned];\n        }\n      });\n    });\n  });\n}\n\nfunction zip(contenders) {\n  var _this = this;\n\n  var iters = asyncIterators(contenders, {\n    returnValues: true\n  });\n  return new Repeater(function (push, stop) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var stopped, resultsP, results, values;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!iters.length) {\n              stop();\n              return [2\n              /*return*/\n              , []];\n            }\n\n            stopped = false;\n            stop.then(function () {\n              return stopped = true;\n            });\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1,, 6, 8]);\n\n            _a.label = 2;\n\n          case 2:\n            if (!!stopped) return [3\n            /*break*/\n            , 5];\n            resultsP = Promise.all(iters.map(function (iter) {\n              return iter.next();\n            }));\n            return [4\n            /*yield*/\n            , Promise.race([stop, resultsP])];\n\n          case 3:\n            results = _a.sent();\n\n            if (results === undefined) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            values = results.map(function (result) {\n              return result.value;\n            });\n\n            if (results.some(function (result) {\n              return result.done;\n            })) {\n              return [2\n              /*return*/\n              , values];\n            }\n\n            return [4\n            /*yield*/\n            , push(values)];\n\n          case 4:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 2];\n\n          case 5:\n            return [3\n            /*break*/\n            , 8];\n\n          case 6:\n            stop();\n            return [4\n            /*yield*/\n            , Promise.all(iters.map(function (iter) {\n              return iter.return && iter.return();\n            }))];\n\n          case 7:\n            _a.sent();\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 8:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  });\n}\n\nfunction latest(contenders) {\n  var _this = this;\n\n  var iters = asyncIterators(contenders, {\n    yieldValues: true,\n    returnValues: true\n  });\n  return new Repeater(function (push, stop) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var stopped, resultsP, results_2, values_1;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!iters.length) {\n              stop();\n              return [2\n              /*return*/\n              , []];\n            }\n\n            stopped = false;\n            stop.then(function () {\n              return stopped = true;\n            });\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1,, 5, 7]);\n\n            resultsP = Promise.all(iters.map(function (iter) {\n              return iter.next();\n            }));\n            return [4\n            /*yield*/\n            , Promise.race([stop, resultsP])];\n\n          case 2:\n            results_2 = _a.sent();\n\n            if (results_2 === undefined) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            values_1 = results_2.map(function (result) {\n              return result.value;\n            });\n\n            if (results_2.every(function (result) {\n              return result.done;\n            })) {\n              return [2\n              /*return*/\n              , values_1];\n            }\n\n            return [4\n            /*yield*/\n            , push(values_1.slice())];\n\n          case 3:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , Promise.all(iters.map(function (iter, i) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var result;\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      if (results_2[i].done) {\n                        return [2\n                        /*return*/\n                        , results_2[i].value];\n                      }\n\n                      _a.label = 1;\n\n                    case 1:\n                      if (!!stopped) return [3\n                      /*break*/\n                      , 5];\n                      return [4\n                      /*yield*/\n                      , Promise.race([stop, iter.next()])];\n\n                    case 2:\n                      result = _a.sent();\n                      if (!(result !== undefined)) return [3\n                      /*break*/\n                      , 4];\n\n                      if (result.done) {\n                        return [2\n                        /*return*/\n                        , result.value];\n                      }\n\n                      values_1[i] = result.value;\n                      return [4\n                      /*yield*/\n                      , push(values_1.slice())];\n\n                    case 3:\n                      _a.sent();\n\n                      _a.label = 4;\n\n                    case 4:\n                      return [3\n                      /*break*/\n                      , 1];\n\n                    case 5:\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            }))];\n\n          case 4:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 5:\n            stop();\n            return [4\n            /*yield*/\n            , Promise.all(iters.map(function (iter) {\n              return iter.return && iter.return();\n            }))];\n\n          case 6:\n            _a.sent();\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  });\n}"},"sourceMaps":{"js":{"mappings":[],"sources":{},"lineCount":null}},"error":null,"hash":"4785039c3d2e2928ae8f1081ce5a172e","cacheData":{"env":{}}}